"use client";
import React, { useState, useEffect, useRef } from 'react';
import axios from 'axios';
import {
  Bold,
  Italic,
  Underline,
  AlignLeft,
  AlignCenter,
  AlignRight,
  List,
  Image as ImageIcon,
  Video,
  Link as LinkIcon,
  Send,
  X,
  Eye,
  Quote,
  Heading1,
  Heading2,
  Heading3,
  Plus,
  Type,
  Minus,
  Hash,
  Code,
  Table,
  Strikethrough,
  IndentIncrease,
  IndentDecrease
} from 'lucide-react';


const ModernBlogEditorV1 = ({
  tokenKey,
  onClose,
  editBlogId,
  editDraftId,
  onSave
}) => {
  const [title, setTitle] = useState('');
  const [content, setContent] = useState('');
  const [paramlink, setParamlink] = useState('');
  const [featuredImage, setFeaturedImage] = useState('');
  const [topics, setTopics] = useState([]);
  const [newTopic, setNewTopic] = useState('');
  const [authorName, setAuthorName] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const [isPublishing, setIsPublishing] = useState(false);
  const [showPreview, setShowPreview] = useState(false);
  const [wordCount, setWordCount] = useState(0);
  const [readTime, setReadTime] = useState(0);
  
  // Calculate word count and read time
  const calculateStats = (text) => {
    const cleanText = text.replace(/<[^>]*>/g, ' ').replace(/\s+/g, ' ').trim();
    const words = cleanText ? cleanText.split(/\s+/).length : 0;
    const time = Math.ceil(words / 200); // Average reading speed is 200 words per minute
    
    setWordCount(words);
    setReadTime(time);
  };
  const [showToolbar, setShowToolbar] = useState(false);
  const [toast, setToast] = useState(null);
  const [lastSaved, setLastSaved] = useState(null);
  const [currentDraftId, setCurrentDraftId] = useState(editDraftId || null);
  const [isEditingPublishedBlog, setIsEditingPublishedBlog] = useState(!!editBlogId);
  const [showVideoOptions, setShowVideoOptions] = useState(false);
  const [activeFormats, setActiveFormats] = useState(new Set());
  const [editorFocused, setEditorFocused] = useState(false);
  const editorRef = useRef(null);
  const fileInputRef = useRef(null);
  const videoInputRef = useRef(null);
  const autoSaveTimerRef = useRef(null);
  const lastContentRef = useRef('');
  const lastTitleRef = useRef('');
  // Refs to track current values for auto-save (avoid stale closures)
  const currentTitleRef = useRef('');
  const currentContentRef = useRef('');
  // Ref to track the last auto-generated paramlink from title
  const lastAutoGeneratedParamlinkRef = useRef('');
  // Track typing activity for auto-save
  const typingActivityRef = useRef(false);
  const lastTypingTimeRef = useRef(Date.now());
  const typingActivityTimerRef = useRef(null);

  function markTypingActivity() {
    typingActivityRef.current = true;
    lastTypingTimeRef.current = Date.now();
    if (typingActivityTimerRef.current) {
      clearTimeout(typingActivityTimerRef.current);
    }
    typingActivityTimerRef.current = setTimeout(() => {
      const timeSinceLastTyping = Date.now() - lastTypingTimeRef.current;
      if (timeSinceLastTyping >= 120000) {
        typingActivityRef.current = false;
      }
    }, 120000);
  }

  const getAuthHeaders = () => {
    const token = localStorage.getItem(tokenKey);
    return {
      headers: {
        Authorization: `Bearer ${token}`,
        'Content-Type': 'application/json',
      },
    };
  };

  // Track content changes with MutationObserver to ensure updates are captured
  useEffect(() => {
    if (!editorRef.current) return;
   
    let debounceTimer = null;
   
    const observer = new MutationObserver((mutations) => {
      // Content changed, update state
      updateContent();
     
      // Check if any media elements were added
      const hasMediaAdded = mutations.some(mutation => {
        return Array.from(mutation.addedNodes).some(node => {
          if (node.nodeType === Node.ELEMENT_NODE) {
            const el = node;
            return el.tagName === 'IMG' || el.tagName === 'VIDEO' || el.tagName === 'IFRAME' ||
                   el.querySelector('img, video, iframe') !== null;
          }
          return false;
        });
      });
     
      // Check for remove buttons if media was added or if content changed significantly
      if (hasMediaAdded) {
        if (debounceTimer) clearTimeout(debounceTimer);
        debounceTimer = setTimeout(() => {
          attachRemoveButtonsToMedia();
        }, 200);
      } else {
        // Also check periodically to catch any missed media elements
        if (debounceTimer) clearTimeout(debounceTimer);
        debounceTimer = setTimeout(() => {
          attachRemoveButtonsToMedia();
        }, 1000);
      }
    });
   
    observer.observe(editorRef.current, {
      childList: true,
      subtree: true,
      characterData: true,
      attributes: true,
      attributeFilter: ['src', 'href'] // Track image/video src changes
    });
   
    return () => {
      observer.disconnect();
      if (debounceTimer) clearTimeout(debounceTimer);
    };
  }, []);

  // Update active formats when selection changes
  useEffect(() => {
    if (!editorRef.current) return;
   
    const handleSelectionChange = () => {
      updateActiveFormats();
    };
   
    const handleMouseUp = () => {
      updateActiveFormats();
    };
   
    const handleKeyDown = () => {
      // Update formats after key press with slight delay to ensure DOM is updated
      setTimeout(updateActiveFormats, 1);
    };
    
    const handleFocus = () => {
      setEditorFocused(true);
      updateActiveFormats();
    };
    
    const handleBlur = () => {
      setEditorFocused(false);
    };
   
    document.addEventListener('selectionchange', handleSelectionChange);
    editorRef.current.addEventListener('mouseup', handleMouseUp);
    editorRef.current.addEventListener('keydown', handleKeyDown);
    editorRef.current.addEventListener('focus', handleFocus);
    editorRef.current.addEventListener('blur', handleBlur);
   
    return () => {
      document.removeEventListener('selectionchange', handleSelectionChange);
      if (editorRef.current) {
        editorRef.current.removeEventListener('mouseup', handleMouseUp);
        editorRef.current.removeEventListener('keydown', handleKeyDown);
        editorRef.current.removeEventListener('focus', handleFocus);
        editorRef.current.removeEventListener('blur', handleBlur);
      }
    };
  }, []);

  useEffect(() => {
    const load = async () => {
      try {
        if (editBlogId) {
          const res = await axios.get(`/api/blog/published?id=${editBlogId}`, getAuthHeaders());
          if (res.data && res.data.success && res.data.blog) {
            const b = res.data.blog;
            const initialContent = b.content || '';
            setTitle(b.title || '');
            setParamlink(b.paramlink || '');
            setAuthorName((b.postedBy && (b.postedBy.name || b.postedBy.username)) || b.postedBy || '');
            setContent(initialContent);
            setTimeout(() => {
              if (editorRef.current) {
                editorRef.current.innerHTML = initialContent;
                // Update content and stats after loading
                updateContent();
              }
            }, 0);
            const t = Array.isArray(b.topics) && b.topics.length ? b.topics : extractTopics(initialContent);
            setTopics(t);
            
            // When editing a published blog directly, we need to set the editing state
            setIsEditingPublishedBlog(true);
          }
        } else if (editDraftId) {
          const res = await axios.get(`/api/blog/draft?id=${editDraftId}`, getAuthHeaders());
          if (res.data && res.data.success && res.data.draft) {
            const d = res.data.draft;
            const initialContent = d.content || '';
            setTitle(d.title || '');
            setParamlink(d.paramlink || '');
            setAuthorName((d.postedBy && (d.postedBy.name || d.postedBy.username)) || d.postedBy || '');
            setContent(initialContent);
            setCurrentDraftId(editDraftId);
            setTimeout(() => {
              if (editorRef.current) {
                editorRef.current.innerHTML = initialContent;
                // Update content and stats after loading
                updateContent();
              }
            }, 0);
            const t = Array.isArray(d.topics) && d.topics.length ? d.topics : extractTopics(initialContent);
            setTopics(t);
            
            // When editing a draft, we're not editing a published blog directly
            setIsEditingPublishedBlog(false);
          }
        }
      } catch (e) {
        console.error('Error loading blog/draft:', e);
      }
    };
    load();
  }, [editBlogId, editDraftId]);



  // Auto-save functionality - saves every 30 seconds (for testing) when user starts writing
  // TODO: Change back to 120000ms (2 minutes) after testing
  useEffect(() => {
    // Clear any existing timer
    if (autoSaveTimerRef.current) {
      clearInterval(autoSaveTimerRef.current);
    }

    // Set up auto-save interval (30 seconds = 30000ms for testing)
    autoSaveTimerRef.current = setInterval(() => {
      // Only save if typing activity is detected (user has started writing)
      if (!typingActivityRef.current) {
        console.log('Auto-save: Skipped - no typing activity detected');
        return; // Skip auto-save if no typing activity
      }

      // Get latest values from refs (avoid stale closures)
      const latestTitle = currentTitleRef.current || '';
      const latestContent = currentContentRef.current || '';
      const editorContent = editorRef.current?.innerHTML?.trim() || '';
     
      // Check if there's actual content (not just empty HTML)
      const hasRealContent = latestTitle.trim() ||
                            latestContent.trim() ||
                            (editorContent && editorContent !== '<p><br></p>' && editorContent !== '<br>' && editorContent !== '<p></p>');
     
      if (!hasRealContent) {
        console.log('Auto-save: Skipped - no content to save');
        return;
      }
     
      // Handle auto-save for all cases including editing published blogs
      if (currentDraftId || editDraftId) {
        // We have an existing draft, update it
        console.log('Auto-save: Attempting to update existing draft (typing activity detected)', {
          draftId: currentDraftId || editDraftId,
          title: latestTitle.substring(0, 50),
          contentLength: latestContent.length
        });
        saveDraft(true); // true indicates auto-save
      } else if (isEditingPublishedBlog && editBlogId) {
        // Editing published blog directly - convert to draft first, then auto-save
        console.log('Auto-save: Converting published blog to draft and saving', {
          blogId: editBlogId,
          title: latestTitle.substring(0, 50)
        });
        convertPublishedToDraft().then(draftId => {
          if (draftId) {
            // After conversion, trigger auto-save on the new draft
            setTimeout(() => {
              saveDraft(true); // Auto-save the newly created draft
            }, 1000); // Small delay to ensure state is updated
          }
        });
      } else {
        // No draft yet, create one if user has typed something
        console.log('Auto-save: Attempting to create new draft (typing activity detected)', {
          title: latestTitle.substring(0, 50) || 'Untitled',
          contentLength: latestContent.length
        });
        saveDraft(true); // This will create the first draft
      }
    }, 30000); // 30 seconds (for testing - change back to 120000 for 2 minutes)

    // Cleanup on unmount
    return () => {
      if (autoSaveTimerRef.current) {
        clearInterval(autoSaveTimerRef.current);
      }
      if (typingActivityTimerRef.current) {
        clearTimeout(typingActivityTimerRef.current);
      }
    };
  }, [currentDraftId, editDraftId, isEditingPublishedBlog]); // Re-run when draft ID or published blog edit status changes

  // Ensure editor always has cursor when empty
  useEffect(() => {
    if (editorRef.current) {
      const checkCursor = () => {
        if (editorRef.current) {
          const isEmpty = !editorRef.current.textContent || editorRef.current.textContent.trim() === '';
          if (isEmpty && editorRef.current.innerHTML === '') {
            // Add a paragraph to ensure cursor is visible
            editorRef.current.innerHTML = '<p><br></p>';
            const range = document.createRange();
            const selection = window.getSelection();
            if (selection && editorRef.current.firstChild) {
              range.setStart(editorRef.current.firstChild, 0);
              range.collapse(true);
              selection.removeAllRanges();
              selection.addRange(range);
            }
          }
        }
      };
     
      // Check on mount and after content changes
      const timer = setTimeout(checkCursor, 100);
      return () => clearTimeout(timer);
    }
  }, []);

  // Check if a formatting command is currently active
  const checkCommandState = (command, value) => {
    if (!editorRef.current) return false;
   
    try {
      const selection = window.getSelection();
      if (!selection || selection.rangeCount === 0) return false;
     
      const range = selection.getRangeAt(0);
      const container = range.commonAncestorContainer;
      const element = container.nodeType === Node.TEXT_NODE
        ? container.parentElement
        : container;
     
      if (!element) return false;
     
      // For formatBlock commands, check the current block element
      if (command === 'formatBlock' && value) {
        const tagName = value.replace(/[<>]/g, '').toLowerCase();
        let current = element;
        while (current && current !== editorRef.current) {
          if (current.tagName && current.tagName.toLowerCase() === tagName) {
            return true;
          }
          current = current.parentElement;
        }
        return false;
      }
     
      // For list commands, check if cursor is inside a list
      if (command === 'insertUnorderedList') {
        let current = element;
        while (current && current !== editorRef.current) {
          if (current.tagName && current.tagName.toLowerCase() === 'ul') {
            return true;
          }
          if (current.tagName && current.tagName.toLowerCase() === 'li') {
            const parent = current.parentElement;
            if (parent && parent.tagName && parent.tagName.toLowerCase() === 'ul') {
              return true;
            }
          }
          current = current.parentElement;
        }
        // Fallback to queryCommandState
        try {
          return document.queryCommandState(command);
        } catch {
          return false;
        }
      }
     
      if (command === 'insertOrderedList') {
        let current = element;
        while (current && current !== editorRef.current) {
          if (current.tagName && current.tagName.toLowerCase() === 'ol') {
            return true;
          }
          if (current.tagName && current.tagName.toLowerCase() === 'li') {
            const parent = current.parentElement;
            if (parent && parent.tagName && parent.tagName.toLowerCase() === 'ol') {
              return true;
            }
          }
          current = current.parentElement;
        }
        // Fallback to queryCommandState
        try {
          return document.queryCommandState(command);
        } catch {
          return false;
        }
      }
     
      // For alignment commands
      if (command.startsWith('justify')) {
        const textAlign = window.getComputedStyle(element).textAlign;
        const commandMap = {
          'justifyLeft': 'left',
          'justifyCenter': 'center',
          'justifyRight': 'right',
        };
        return textAlign === commandMap[command];
      }
      
      // For indent/outdent commands
      if (command === 'indent' || command === 'outdent') {
        // Check if element has margin/padding that suggests indentation
        const marginLeft = parseInt(window.getComputedStyle(element).marginLeft);
        return marginLeft > 0;
      }
      
      // For strike-through
      if (command === 'strikeThrough') {
        const textDecoration = window.getComputedStyle(element).textDecoration;
        return textDecoration.includes('line-through');
      }
      
      // For horizontal rule
      if (command === 'insertHorizontalRule') {
        const hrElements = editorRef.current.querySelectorAll('hr');
        return hrElements.length > 0;
      }
     
      // For standard commands, use queryCommandState
      try {
        return document.queryCommandState(command);
      } catch {
        return false;
      }
    } catch (error) {
      return false;
    }
  };

  // Update active formats based on current selection
  const updateActiveFormats = () => {
    if (!editorRef.current) return;
   
    const formats = new Set();
   
    // Check text formatting
    if (checkCommandState('bold')) formats.add('bold');
    if (checkCommandState('italic')) formats.add('italic');
    if (checkCommandState('underline')) formats.add('underline');
    if (checkCommandState('strikeThrough')) formats.add('strikeThrough');
    if (checkCommandState('insertHorizontalRule')) formats.add('insertHorizontalRule');
   
    // Check headings
    if (checkCommandState('formatBlock', '<h1>')) formats.add('h1');
    if (checkCommandState('formatBlock', '<h2>')) formats.add('h2');
    if (checkCommandState('formatBlock', '<h3>')) formats.add('h3');
   
    // Check alignment
    if (checkCommandState('justifyLeft')) formats.add('justifyLeft');
    if (checkCommandState('justifyCenter')) formats.add('justifyCenter');
    if (checkCommandState('justifyRight')) formats.add('justifyRight');
    if (checkCommandState('outdent')) formats.add('outdent');
    if (checkCommandState('indent')) formats.add('indent');
   
    // Check lists
    if (checkCommandState('insertUnorderedList')) formats.add('insertUnorderedList');
    if (checkCommandState('insertOrderedList')) formats.add('insertOrderedList');
   
    // Check blockquote
    if (checkCommandState('formatBlock', '<blockquote>')) formats.add('blockquote');
    
    // Check code formatting
    if (checkCommandState('formatBlock', '<pre>')) formats.add('pre');
    if (checkCommandState('fontName')) formats.add('fontName');
   
    setActiveFormats(formats);
  };

  // Format text with proper selection handling
  const formatText = (command, value) => {
    if (!editorRef.current) return;
   
    editorRef.current.focus();
   
    // Get current selection
    let selection = window.getSelection();
    let range = null;
   
    if (selection && selection.rangeCount > 0) {
      range = selection.getRangeAt(0);
    } else {
      // No selection, create a range at cursor
      range = document.createRange();
      if (editorRef.current.childNodes.length > 0) {
        const lastNode = editorRef.current.childNodes[editorRef.current.childNodes.length - 1];
        if (lastNode.nodeType === Node.TEXT_NODE) {
          range.setStart(lastNode, lastNode.length);
          range.setEnd(lastNode, lastNode.length);
        } else {
          range.setStartAfter(lastNode);
          range.setEndAfter(lastNode);
        }
      } else {
        range.selectNodeContents(editorRef.current);
        range.collapse(false);
      }
      selection = window.getSelection();
      if (selection) {
        selection.removeAllRanges();
        selection.addRange(range);
      }
    }

    try {
      // Special handling for list commands
      if (command === 'insertUnorderedList' || command === 'insertOrderedList') {
        // Ensure we have a block element to work with
        if (!range || range.collapsed) {
          const container = range?.commonAncestorContainer;
          let blockElement = null;
         
          if (container) {
            if (container.nodeType === Node.TEXT_NODE) {
              blockElement = container.parentElement;
            } else {
              blockElement = container;
            }
           
            // Find block-level parent
            while (blockElement && blockElement !== editorRef.current) {
              const tagName = blockElement.tagName?.toLowerCase();
              if (tagName && ['p', 'div', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'li'].includes(tagName)) {
                break;
              }
              blockElement = blockElement.parentElement;
            }
          }
         
          // If no block found or editor is empty, create a paragraph
          if (!blockElement || blockElement === editorRef.current || editorRef.current.textContent?.trim() === '') {
            const p = document.createElement('p');
            const br = document.createElement('br');
            p.appendChild(br);
            if (editorRef.current.childNodes.length === 0) {
              editorRef.current.appendChild(p);
            } else {
              editorRef.current.appendChild(p);
            }
           
            // Set selection inside the paragraph
            const newRange = document.createRange();
            newRange.setStart(p, 0);
            newRange.setEnd(p, 0);
            selection = window.getSelection();
            if (selection) {
              selection.removeAllRanges();
              selection.addRange(newRange);
            }
          } else if (blockElement.tagName?.toLowerCase() === 'li') {
            // Already in a list item, select it
            const newRange = document.createRange();
            newRange.selectNodeContents(blockElement);
            selection = window.getSelection();
            if (selection) {
              selection.removeAllRanges();
              selection.addRange(newRange);
            }
          }
        }
       
        // Execute list command
        const success = document.execCommand(command, false);
        if (!success) {
          console.warn(`execCommand ${command} returned false`);
        }
      }
      // Special handling for formatBlock (headings, blockquote)
      else if (command === 'formatBlock' && value) {
        // If no selection or collapsed selection, select the current block
        if (!range || range.collapsed) {
          const container = range?.commonAncestorContainer;
          let blockElement = null;
         
          if (container) {
            if (container.nodeType === Node.TEXT_NODE) {
              blockElement = container.parentElement;
            } else {
              blockElement = container;
            }
           
            // Find the block-level parent
            while (blockElement && blockElement !== editorRef.current) {
              const tagName = blockElement.tagName?.toLowerCase();
              if (tagName && ['p', 'div', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'blockquote', 'li', 'pre'].includes(tagName)) {
                break;
              }
              blockElement = blockElement.parentElement;
            }
           
            if (blockElement && blockElement !== editorRef.current) {
              // Select the entire block
              const newRange = document.createRange();
              newRange.selectNodeContents(blockElement);
              selection = window.getSelection();
              if (selection) {
                selection.removeAllRanges();
                selection.addRange(newRange);
              }
            } else {
              // No block found, create one
              const tagName = value.replace(/[<>]/g, '').toLowerCase();
              const newElement = document.createElement(tagName);
              const br = document.createElement('br');
              newElement.appendChild(br);
             
              if (editorRef.current.childNodes.length === 0) {
                editorRef.current.appendChild(newElement);
              } else {
                editorRef.current.appendChild(newElement);
              }
             
              // Set selection inside new element
              const newRange = document.createRange();
              newRange.setStart(newElement, 0);
              newRange.setEnd(newElement, 0);
              selection = window.getSelection();
              if (selection) {
                selection.removeAllRanges();
                selection.addRange(newRange);
              }
            }
          } else {
            // No container, create new element
            const tagName = value.replace(/[<>]/g, '').toLowerCase();
            const newElement = document.createElement(tagName);
            const br = document.createElement('br');
            newElement.appendChild(br);
            editorRef.current.appendChild(newElement);
           
            const newRange = document.createRange();
            newRange.setStart(newElement, 0);
            newRange.setEnd(newElement, 0);
            selection = window.getSelection();
            if (selection) {
              selection.removeAllRanges();
              selection.addRange(newRange);
            }
          }
        }
       
        // Execute formatBlock command
        const success = document.execCommand(command, false, value);
        if (!success) {
          console.warn(`execCommand ${command} with value ${value} returned false`);
        }
      }
      // Special handling for indent/outdent
      else if (command === 'indent' || command === 'outdent') {
        const success = document.execCommand(command, false);
        if (!success) {
          console.warn(`execCommand ${command} returned false`);
          // Fallback: manually adjust margins
          if (selection && selection.anchorOffset !== undefined) {
            const selectedText = selection.toString();
            if (selectedText) {
              const range = selection.getRangeAt(0);
              const element = range.startContainer.parentElement;
              if (element && element.tagName !== 'LI') {
                const currentMargin = parseInt(window.getComputedStyle(element).marginLeft) || 0;
                if (command === 'indent') {
                  element.style.marginLeft = (currentMargin + 20) + 'px';
                } else {
                  element.style.marginLeft = Math.max(0, currentMargin - 20) + 'px';
                }
              }
            }
          }
        }
      }
      // Special handling for horizontal rule
      else if (command === 'insertHorizontalRule') {
        document.execCommand('insertHTML', false, '<hr style="margin: 10px 0;">');
      }
      // Special handling for strikethrough
      else if (command === 'strikeThrough') {
        const success = document.execCommand(command, false);
        if (!success) {
          console.warn(`execCommand ${command} returned false`);
        }
      }
      // Standard commands
      else {
        const success = value
          ? document.execCommand(command, false, value)
          : document.execCommand(command, false);
        if (!success) {
          console.warn(`execCommand ${command} returned false`);
        }
      }
     
      // Update content after formatting
      setTimeout(() => {
        // Remove empty br tags that might have been created
        if (editorRef.current) {
          const brs = editorRef.current.querySelectorAll('br');
          brs.forEach(br => {
            if (!br.nextSibling && !br.previousSibling) {
              const parent = br.parentElement;
              if (parent && parent !== editorRef.current && parent.textContent?.trim() === '') {
                const p = document.createElement('p');
                p.appendChild(document.createElement('br'));
                parent.parentNode?.replaceChild(p, parent);
              }
            }
          });
        }
       
        updateContent();
        updateActiveFormats();
        editorRef.current?.focus();
      }, 10);
    } catch (error) {
      console.error('Error executing command:', error, { command, value });
    }
  };

  const updateContent = () => {
    if (editorRef.current) {
      const htmlContent = editorRef.current.innerHTML || '';
      // Always update content, even if empty (will be handled in save)
      setContent(htmlContent);
      // Update refs for auto-save and change detection
      currentContentRef.current = htmlContent;
      lastContentRef.current = htmlContent;
      // Mark typing activity when user types in editor
      markTypingActivity();
      
      // Calculate stats with delay to improve performance
      setTimeout(() => calculateStats(htmlContent), 0);
    }
  };

  // Clean content for preview by removing remove buttons
  const cleanContentForPreview = (htmlContent) => {
    if (!htmlContent) return htmlContent;
   
    // Create a temporary DOM element to parse and clean HTML
    const tempDiv = document.createElement('div');
    tempDiv.innerHTML = htmlContent;
   
    // Remove all remove buttons (buttons with data-remove-media attribute)
    const removeButtons = tempDiv.querySelectorAll('button[data-remove-media="true"]');
    removeButtons.forEach(btn => btn.remove());
   
    // Also remove buttons in image/video containers that have absolute positioning in their inline style
    const allButtons = tempDiv.querySelectorAll('.image-container button, .video-container button');
    allButtons.forEach(btn => {
      const btnElement = btn;
      const styleAttr = btnElement.getAttribute('style') || '';
      // Check if button has absolute positioning in style attribute
      if (styleAttr.includes('position') && (styleAttr.includes('absolute') || styleAttr.includes('position:absolute'))) {
        btn.remove();
      }
    });
   
    return tempDiv.innerHTML;
  };

  // Add remove buttons to existing images and videos when loading content
  const attachRemoveButtonsToMedia = () => {
    if (!editorRef.current) return;

    // Find all images - use a more comprehensive selector
    const images = editorRef.current.querySelectorAll('img:not(button img)');
    images.forEach((img) => {
      // Skip if image is inside a button (remove button icon)
      if (img.closest('button')) return;
     
      // Check if image is already inside a container
      let existingContainer = img.closest('.image-container');
     
      // If no container found, check if parent is a container
      if (!existingContainer && img.parentElement) {
        const parent = img.parentElement;
        if (parent.classList && parent.classList.contains('image-container')) {
          existingContainer = parent;
        }
      }
     
      // Check if container already has a remove button
      if (existingContainer) {
        const hasRemoveBtn = existingContainer.querySelector('button[data-remove-media="true"]') ||
                            existingContainer.querySelector('button[style*="position: absolute"]') ||
                            existingContainer.querySelector('button[style*="position:absolute"]');
        if (hasRemoveBtn) {
          // Ensure the button has the correct onclick handler
          const btn = existingContainer.querySelector('button[data-remove-media="true"], button[style*="position: absolute"], button[style*="position:absolute"]');
          if (btn && !btn.onclick) {
            btn.onclick = (e) => {
              e.preventDefault();
              e.stopPropagation();
              removeImage(existingContainer);
            };
          }
          return; // Already has remove button
        }
      }

      // Create or get container
      let container;
      if (existingContainer) {
        container = existingContainer;
        // Ensure existing container has proper styling
        container.style.position = 'relative';
        container.style.overflow = 'visible';
        container.style.zIndex = 'auto';
        container.style.display = 'block';
        container.style.textAlign = 'center';
        // Ensure image is centered
        const imgEl = img;
        imgEl.style.display = 'block';
        imgEl.style.margin = '0 auto';
      } else {
        // Wrap image in container
        container = document.createElement('div');
        container.style.position = 'relative';
        container.style.margin = '16px 0';
        container.style.display = 'block';
        container.style.width = '100%';
        container.style.textAlign = 'center';
        container.style.overflow = 'visible';
        container.style.zIndex = 'auto';
        container.className = 'image-container';
       
        // Ensure image is centered
        const imgEl = img;
        imgEl.style.display = 'block';
        imgEl.style.margin = '0 auto';
       
        // Preserve image styles and parent structure
        const imgParent = img.parentNode;
        if (imgParent && editorRef.current && imgParent !== editorRef.current) {
          imgParent.insertBefore(container, img);
          container.appendChild(img);
        } else if (editorRef.current) {
          // If image is direct child of editor, just wrap it
          editorRef.current.insertBefore(container, img);
          container.appendChild(img);
        }
      }

      // Always check and add remove button - be more thorough
      let existingBtn = container.querySelector('button[data-remove-media="true"]');
      if (!existingBtn) {
        // Try finding by style
        const buttons = container.querySelectorAll('button');
        for (let i = 0; i < buttons.length; i++) {
          const btn = buttons[i];
          const style = btn.style.position || window.getComputedStyle(btn).position;
          if (style === 'absolute') {
            existingBtn = btn;
            break;
          }
        }
      }

      if (!existingBtn) {
        // Ensure image has lower z-index so button appears on top
        const imgElement = img;
        imgElement.style.position = 'relative';
        imgElement.style.zIndex = '1';
        imgElement.style.pointerEvents = 'auto';
       
        const removeBtn = document.createElement('button');
        removeBtn.innerHTML = '×';
        removeBtn.setAttribute('data-remove-media', 'true');
        // Use setAttribute for style to ensure it's applied
        removeBtn.setAttribute('style', `
          position: absolute !important;
          top: 8px !important;
          right: 8px !important;
          width: 28px !important;
          height: 28px !important;
          border-radius: 50% !important;
          background-color: rgba(0, 0, 0, 0.6) !important;
          color: white !important;
          border: none !important;
          box-shadow: 0 2px 4px rgba(0, 0, 0, 0.15) !important;
          cursor: pointer !important;
          display: flex !important;
          align-items: center !important;
          justify-content: center !important;
          font-size: 18px !important;
          font-weight: normal !important;
          line-height: 1 !important;
          opacity: 0.7 !important;
          transition: opacity 0.2s ease, transform 0.2s ease, background-color 0.2s ease !important;
          z-index: 99999 !important;
          pointer-events: auto !important;
          visibility: visible !important;
        `);
        removeBtn.onclick = (e) => {
          e.preventDefault();
          e.stopPropagation();
          removeImage(container);
        };

        container.onmouseenter = () => {
          removeBtn.style.opacity = '1';
          removeBtn.style.transform = 'scale(1.1)';
          removeBtn.style.backgroundColor = 'rgba(220, 38, 38, 0.95)'; // More visible red on hover
        };
        container.onmouseleave = () => {
          removeBtn.style.opacity = '0.7';
          removeBtn.style.transform = 'scale(1)';
          removeBtn.style.backgroundColor = 'rgba(0, 0, 0, 0.6)'; // Slightly more visible gray
        };

        // Append button AFTER image to ensure it's on top in DOM order
        container.appendChild(removeBtn);
      } else {
        // Button exists but might not have onclick handler - ensure it does
        if (!existingBtn.onclick) {
          existingBtn.onclick = (e) => {
            e.preventDefault();
            e.stopPropagation();
            removeImage(container);
          };
        }
        // Update existing button styles
        existingBtn.style.backgroundColor = 'rgba(0, 0, 0, 0.6)';
        existingBtn.style.border = 'none';
        existingBtn.style.boxShadow = '0 2px 4px rgba(0, 0, 0, 0.15)';
        existingBtn.style.opacity = '0.7';
        existingBtn.style.zIndex = '99999';
        existingBtn.style.visibility = 'visible';
        existingBtn.style.transition = 'opacity 0.2s ease, transform 0.2s ease, background-color 0.2s ease';
      }
    });

    // Find all videos and iframes
    const videos = editorRef.current.querySelectorAll('video:not(button video), iframe:not(button iframe)');
    videos.forEach((video) => {
      // Skip if video/iframe is inside a button
      if (video.closest('button')) return;
     
      // Check if video is already inside a container
      let existingContainer = video.closest('.video-container');
     
      // If no container found, check if parent is a container
      if (!existingContainer && video.parentElement) {
        const parent = video.parentElement;
        if (parent.classList && parent.classList.contains('video-container')) {
          existingContainer = parent;
        }
      }
     
      // Check if container already has a remove button
      if (existingContainer) {
        const hasRemoveBtn = existingContainer.querySelector('button[data-remove-media="true"]') ||
                            existingContainer.querySelector('button[style*="position: absolute"]') ||
                            existingContainer.querySelector('button[style*="position:absolute"]');
        if (hasRemoveBtn) {
          // Ensure the button has the correct onclick handler
          const btn = existingContainer.querySelector('button[data-remove-media="true"], button[style*="position: absolute"], button[style*="position:absolute"]');
          if (btn && !btn.onclick) {
            btn.onclick = (e) => {
              e.preventDefault();
              e.stopPropagation();
              removeImage(existingContainer);
            };
          }
          return; // Already has remove button
        }
      }

      // Create or get container
      let container;
      if (existingContainer) {
        container = existingContainer;
        // Ensure existing container has proper styling
        container.style.position = 'relative';
        container.style.overflow = 'visible';
        container.style.zIndex = 'auto';
        container.style.display = 'block';
        container.style.textAlign = 'center';
        // Ensure video/iframe is centered
        const videoEl = video;
        videoEl.style.display = 'block';
        videoEl.style.margin = '0 auto';
      } else {
        // Wrap video in container
        container = document.createElement('div');
        container.style.position = 'relative';
        container.style.margin = '16px 0';
        container.style.textAlign = 'center';
        container.style.display = 'block';
        container.style.width = '100%';
        container.style.overflow = 'visible';
        container.style.zIndex = 'auto';
        container.className = 'video-container';
       
        // Ensure video/iframe is centered
        const videoEl = video;
        videoEl.style.display = 'block';
        videoEl.style.margin = '0 auto';
       
        // Preserve video/iframe styles and parent structure
        const videoParent = video.parentNode;
        if (videoParent && editorRef.current && videoParent !== editorRef.current) {
          videoParent.insertBefore(container, video);
          container.appendChild(video);
        } else {
          // If video is direct child of editor, just wrap it
          if (editorRef.current) {
            editorRef.current.insertBefore(container, video);
            container.appendChild(video);
          }
        }
      }

      // Always check and add remove button - be more thorough
      let existingBtn = container.querySelector('button[data-remove-media="true"]');
      if (!existingBtn) {
        // Try finding by style
        const buttons = container.querySelectorAll('button');
        for (let i = 0; i < buttons.length; i++) {
          const btn = buttons[i];
          const style = btn.style.position || window.getComputedStyle(btn).position;
          if (style === 'absolute') {
            existingBtn = btn;
            break;
          }
        }
      }

      if (!existingBtn) {
        // Ensure video/iframe has lower z-index so button appears on top
        const videoElement = video;
        videoElement.style.position = 'relative';
        videoElement.style.zIndex = '1';
        videoElement.style.pointerEvents = 'auto';
       
        const removeBtn = document.createElement('button');
        removeBtn.innerHTML = '×';
        removeBtn.setAttribute('data-remove-media', 'true');
        // Use setAttribute for style to ensure it's applied
        removeBtn.setAttribute('style', `
          position: absolute !important;
          top: 8px !important;
          right: 8px !important;
          width: 28px !important;
          height: 28px !important;
          border-radius: 50% !important;
          background-color: rgba(0, 0, 0, 0.6) !important;
          color: white !important;
          border: none !important;
          box-shadow: 0 2px 4px rgba(0, 0, 0, 0.15) !important;
          cursor: pointer !important;
          display: flex !important;
          align-items: center !important;
          justify-content: center !important;
          font-size: 18px !important;
          font-weight: normal !important;
          line-height: 1 !important;
          opacity: 0.7 !important;
          transition: opacity 0.2s ease, transform 0.2s ease, background-color 0.2s ease !important;
          z-index: 99999 !important;
          pointer-events: auto !important;
          visibility: visible !important;
        `);
        removeBtn.onclick = (e) => {
          e.preventDefault();
          e.stopPropagation();
          removeImage(container);
        };

        container.onmouseenter = () => {
          removeBtn.style.setProperty('opacity', '1', 'important');
          removeBtn.style.setProperty('transform', 'scale(1.1)', 'important');
          removeBtn.style.setProperty('background-color', 'rgba(220, 38, 38, 0.95)', 'important');
        };
        container.onmouseleave = () => {
          removeBtn.style.setProperty('opacity', '0.7', 'important');
          removeBtn.style.setProperty('transform', 'scale(1)', 'important');
          removeBtn.style.setProperty('background-color', 'rgba(0, 0, 0, 0.6)', 'important');
        };

        // Append button AFTER video to ensure it's on top in DOM order
        container.appendChild(removeBtn);
      } else {
        // Button exists but might not have onclick handler - ensure it does
        if (!existingBtn.onclick) {
          existingBtn.onclick = (e) => {
            e.preventDefault();
            e.stopPropagation();
            removeImage(container);
          };
        }
        // Update existing button styles
        existingBtn.style.backgroundColor = 'rgba(0, 0, 0, 0.6)';
        existingBtn.style.border = 'none';
        existingBtn.style.boxShadow = '0 2px 4px rgba(0, 0, 0, 0.15)';
        existingBtn.style.opacity = '0.7';
        existingBtn.style.fontWeight = 'normal';
        existingBtn.style.fontSize = '18px';
        existingBtn.style.width = '28px';
        existingBtn.style.height = '28px';
        existingBtn.style.zIndex = '99999';
        existingBtn.style.visibility = 'visible';
        existingBtn.style.transition = 'opacity 0.2s ease, transform 0.2s ease, background-color 0.2s ease';
      }
    });
  };

  // Handle paste events to clean HTML
  const handlePaste = (e) => {
    e.preventDefault();
    const text = e.clipboardData.getData('text/plain');
    document.execCommand('insertText', false, text);
    updateContent();
  };

  // Unified function to remove images and videos from editor
  const removeImage = (mediaContainer) => {
    if (!editorRef.current) return;
   
    // Create a paragraph after the media for cursor positioning
    const p = document.createElement('p');
    p.innerHTML = '<br>';
   
    // Insert paragraph after media container - use insertAdjacentElement for safety
    if (mediaContainer.parentNode) {
      mediaContainer.insertAdjacentElement('afterend', p);
    } else {
      editorRef.current.appendChild(p);
    }
   
    // Remove the media container (works for both images and videos)
    mediaContainer.remove();
   
    // Set cursor in the new paragraph
    const range = document.createRange();
    range.selectNodeContents(p);
    range.collapse(true);
    const selection = window.getSelection();
    if (selection) {
      selection.removeAllRanges();
      selection.addRange(range);
    }
   
    editorRef.current.focus();
    // Update content immediately to save changes (important for drafts)
    updateContent();
    // Trigger a re-attachment check for any remaining media
    setTimeout(() => {
      attachRemoveButtonsToMedia();
    }, 100);
  };

  const insertVideoFromUrl = (url) => {
    if (!editorRef.current || !url.trim()) return;
   
    editorRef.current.focus();
   
    let embedUrl = url.trim();
    let videoType = 'iframe';
   
    // YouTube URL handling
    if (url.includes('youtube.com/watch?v=')) {
      const videoId = url.split('v=')[1]?.split('&')[0];
      embedUrl = `https://www.youtube.com/embed/${videoId}`;
    } else if (url.includes('youtu.be/')) {
      const videoId = url.split('youtu.be/')[1]?.split('?')[0];
      embedUrl = `https://www.youtube.com/embed/${videoId}`;
    } else if (url.includes('youtube.com/embed/')) {
      embedUrl = url;
    }
    // Vimeo URL handling
    else if (url.includes('vimeo.com/')) {
      const videoId = url.split('vimeo.com/')[1]?.split('?')[0];
      embedUrl = `https://player.vimeo.com/video/${videoId}`;
    }
    // Dailymotion URL handling
    else if (url.includes('dailymotion.com/video/')) {
      const videoId = url.split('dailymotion.com/video/')[1]?.split('?')[0];
      embedUrl = `https://www.dailymotion.com/embed/video/${videoId}`;
    } else if (url.includes('dai.ly/')) {
      const videoId = url.split('dai.ly/')[1]?.split('?')[0];
      embedUrl = `https://www.dailymotion.com/embed/video/${videoId}`;
    }
    // Direct video file (MP4, WebM, etc.)
    else if (url.match(/\.(mp4|webm|ogg|mov|avi|wmv|flv)(\?.*)?$/i)) {
      videoType = 'video';
    }
    // Generic iframe URL
    else if (url.includes('embed') || url.includes('iframe')) {
      embedUrl = url;
    }
    // If none match, try to use as direct video URL
    else {
      videoType = 'video';
    }
   
    const container = document.createElement('div');
    container.style.position = 'relative';
    container.style.margin = '16px 0';
    container.style.textAlign = 'center';
    container.style.display = 'inline-block';
    container.style.width = '100%';
    container.className = 'video-container';
   
    let mediaElement;
   
    if (videoType === 'video') {
      const video = document.createElement('video');
      video.src = embedUrl;
      video.controls = true;
      video.style.width = '100%';
      video.style.maxWidth = '100%';
      video.style.height = 'auto';
      video.style.borderRadius = '12px';
      video.style.display = 'block';
      video.style.position = 'relative';
      video.style.zIndex = '1';
      mediaElement = video;
    } else {
      const iframe = document.createElement('iframe');
      iframe.src = embedUrl;
      iframe.width = '100%';
      iframe.height = '400';
      iframe.style.maxWidth = '100%';
      iframe.style.borderRadius = '12px';
      iframe.style.border = 'none';
      iframe.style.position = 'relative';
      iframe.style.zIndex = '1';
      iframe.allow = 'accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture';
      iframe.allowFullscreen = true;
      mediaElement = iframe;
    }
   
    // Create remove button
    const removeBtn = document.createElement('button');
    removeBtn.innerHTML = '×';
    removeBtn.setAttribute('data-remove-media', 'true');
    removeBtn.style.position = 'absolute';
    removeBtn.style.top = '8px';
    removeBtn.style.right = '8px';
    removeBtn.style.width = '28px';
    removeBtn.style.height = '28px';
    removeBtn.style.borderRadius = '50%';
    removeBtn.style.backgroundColor = 'rgba(0, 0, 0, 0.6)';
    removeBtn.style.color = 'white';
    removeBtn.style.border = 'none';
    removeBtn.style.boxShadow = '0 2px 4px rgba(0, 0, 0, 0.15)';
    removeBtn.style.cursor = 'pointer';
    removeBtn.style.display = 'flex';
    removeBtn.style.alignItems = 'center';
    removeBtn.style.justifyContent = 'center';
    removeBtn.style.fontSize = '18px';
    removeBtn.style.fontWeight = 'normal';
    removeBtn.style.lineHeight = '1';
    removeBtn.style.opacity = '0.7';
    removeBtn.style.transition = 'opacity 0.2s ease, transform 0.2s ease, background-color 0.2s ease';
    removeBtn.style.zIndex = '9999';
    removeBtn.style.pointerEvents = 'auto';
    removeBtn.onclick = (e) => {
      e.preventDefault();
      e.stopPropagation();
      const p = document.createElement('p');
      p.innerHTML = '<br>';
      if (container.parentNode) {
        container.insertAdjacentElement('afterend', p);
      } else {
        editorRef.current?.appendChild(p);
      }
      container.remove();
      const range = document.createRange();
      range.selectNodeContents(p);
      range.collapse(true);
      const selection = window.getSelection();
      if (selection) {
        selection.removeAllRanges();
        selection.addRange(range);
      }
      editorRef.current?.focus();
      updateContent();
    };
   
    container.onmouseenter = () => {
      removeBtn.style.opacity = '1';
      removeBtn.style.transform = 'scale(1.05)';
      removeBtn.style.backgroundColor = 'rgba(220, 38, 38, 0.9)'; // Subtle red on hover
    };
    container.onmouseleave = () => {
      removeBtn.style.opacity = '0.7';
      removeBtn.style.transform = 'scale(1)';
      removeBtn.style.backgroundColor = 'rgba(0, 0, 0, 0.6)'; // Back to dark gray
    };
   
    container.appendChild(mediaElement);
    container.appendChild(removeBtn);
   
    const p = document.createElement('p');
    p.innerHTML = '<br>';
   
    const selection = window.getSelection();
    if (selection && selection.rangeCount > 0) {
      const range = selection.getRangeAt(0);
      range.deleteContents();
      range.insertNode(container);
     
      if (container.parentNode) {
        container.insertAdjacentElement('afterend', p);
      } else {
        editorRef.current.appendChild(p);
      }
     
      const newRange = document.createRange();
      newRange.selectNodeContents(p);
      newRange.collapse(true);
      selection.removeAllRanges();
      selection.addRange(newRange);
    } else {
      editorRef.current.appendChild(container);
      editorRef.current.appendChild(p);
     
      const range = document.createRange();
      range.selectNodeContents(p);
      range.collapse(true);
      const newSelection = window.getSelection();
      if (newSelection) {
        newSelection.removeAllRanges();
        newSelection.addRange(range);
      }
    }
   
    editorRef.current.focus();
    updateContent();
  };

  const handleImageUpload = async (e) => {
    const file = e.target.files?.[0];
    if (!file) return;

    if (file.size > 5 * 1024 * 1024) {
      showToast('Image size should be less than 5MB', 'error');
      if (fileInputRef.current) {
        fileInputRef.current.value = '';
      }
      return;
    }

    if (!file.type.startsWith('image/')) {
      showToast('Please select a valid image file', 'error');
      if (fileInputRef.current) {
        fileInputRef.current.value = '';
      }
      return;
    }

    // Show loading state
    showToast('Uploading image...', 'success');
   
    try {
      // Upload image to server first to avoid base64 in content (prevents 413 error)
      const formData = new FormData();
      formData.append('file', file);
     
      const token = localStorage.getItem(tokenKey);
     
      // Upload to server
      const uploadResponse = await axios.post(
        '/api/blog/upload',
        formData,
        {
          headers: {
            ...(token ? { Authorization: `Bearer ${token}` } : {}),
            // Don't set Content-Type - let browser set it with boundary for multipart/form-data
          },
        }
      );
     
      if (!uploadResponse.data || !uploadResponse.data.url) {
        throw new Error('Upload failed: No URL returned from server');
      }
     
      const imageUrl = uploadResponse.data.url;
     
      if (editorRef.current) {
        editorRef.current.focus();
       
        // Create container div for image with remove button
        const container = document.createElement('div');
        container.style.position = 'relative';
        container.style.margin = '16px 0';
        container.style.display = 'block';
        container.style.width = '100%';
        container.style.textAlign = 'center';
        container.className = 'image-container';
       
        const img = document.createElement('img');
        img.src = imageUrl;
        img.style.maxWidth = '100%';
        img.style.height = 'auto';
        img.style.borderRadius = '12px';
        img.style.display = 'block';
        img.style.margin = '0 auto';
        img.style.position = 'relative';
        img.style.zIndex = '1';
        img.alt = 'Uploaded image';
       
        // Create remove button
        const removeBtn = document.createElement('button');
        removeBtn.innerHTML = '×';
        removeBtn.setAttribute('data-remove-media', 'true');
        removeBtn.style.position = 'absolute';
        removeBtn.style.top = '8px';
        removeBtn.style.right = '8px';
        removeBtn.style.width = '28px';
        removeBtn.style.height = '28px';
        removeBtn.style.borderRadius = '50%';
        removeBtn.style.backgroundColor = 'rgba(0, 0, 0, 0.5)';
        removeBtn.style.color = 'white';
        removeBtn.style.border = 'none';
        removeBtn.style.boxShadow = '0 2px 4px rgba(0, 0, 0, 0.15)';
        removeBtn.style.cursor = 'pointer';
        removeBtn.style.display = 'flex';
        removeBtn.style.alignItems = 'center';
        removeBtn.style.justifyContent = 'center';
        removeBtn.style.fontSize = '18px';
        removeBtn.style.fontWeight = 'normal';
        removeBtn.style.lineHeight = '1';
        removeBtn.style.opacity = '0.7';
        removeBtn.style.transition = 'opacity 0.2s ease, transform 0.2s ease, background-color 0.2s ease';
        removeBtn.style.zIndex = '99999';
        removeBtn.style.pointerEvents = 'auto';
        removeBtn.style.visibility = 'visible';
        removeBtn.onclick = (e) => {
          e.preventDefault();
          e.stopPropagation();
          removeImage(container);
        };
       
        // Show remove button on hover with scale effect
        container.onmouseenter = () => {
          removeBtn.style.opacity = '1';
          removeBtn.style.transform = 'scale(1.1)';
          removeBtn.style.backgroundColor = 'rgba(220, 38, 38, 0.95)'; // More visible red on hover
        };
        container.onmouseleave = () => {
          removeBtn.style.opacity = '0.7';
          removeBtn.style.transform = 'scale(1)';
          removeBtn.style.backgroundColor = 'rgba(0, 0, 0, 0.6)'; // Slightly more visible gray
        };
       
        container.appendChild(img);
        container.appendChild(removeBtn);
       
        // Create paragraph after image for cursor positioning
        const p = document.createElement('p');
        p.innerHTML = '<br>';
       
        const selection = window.getSelection();
        if (selection && selection.rangeCount > 0) {
          const range = selection.getRangeAt(0);
          range.deleteContents();
          range.insertNode(container);
         
          // Insert paragraph after container - use insertAdjacentElement for safety
          if (container.parentNode) {
            container.insertAdjacentElement('afterend', p);
          } else {
            editorRef.current.appendChild(p);
          }
         
          // Move cursor to the paragraph after image
          const newRange = document.createRange();
          newRange.selectNodeContents(p);
          newRange.collapse(true);
          selection.removeAllRanges();
          selection.addRange(newRange);
        } else {
          // Append at end
          editorRef.current.appendChild(container);
          editorRef.current.appendChild(p);
         
          // Set cursor in the paragraph
          const range = document.createRange();
          range.selectNodeContents(p);
          range.collapse(true);
          const newSelection = window.getSelection();
          if (newSelection) {
            newSelection.removeAllRanges();
            newSelection.addRange(range);
          }
        }
       
        editorRef.current.focus();
       
        // Force content update immediately after image insertion
        setTimeout(() => {
          updateContent();
          // Trigger input event to ensure content is tracked
          const inputEvent = new Event('input', { bubbles: true });
          editorRef.current?.dispatchEvent(inputEvent);
        }, 100);
       
        showToast('Image uploaded successfully', 'success');
      }
    } catch (error) {
      console.error('Error uploading image:', error);
      const errorMessage = error.response?.data?.error || error.message || 'Failed to upload image';
      showToast(errorMessage, 'error');
      alert(`Failed to upload image: ${errorMessage}`);
    } finally {
      // Reset input
      if (fileInputRef.current) {
        fileInputRef.current.value = '';
      }
    }
  };

  const handleVideoUpload = (e) => {
    const file = e.target.files?.[0];
    if (!file) return;

    if (file.size > 100 * 1024 * 1024) {
      showToast('Video size should be less than 100MB', 'error');
      if (videoInputRef.current) {
        videoInputRef.current.value = '';
      }
      return;
    }

    if (!file.type.startsWith('video/')) {
      showToast('Please select a valid video file', 'error');
      if (videoInputRef.current) {
        videoInputRef.current.value = '';
      }
      return;
    }

    const reader = new FileReader();
    reader.onload = (event) => {
      const videoUrl = typeof event.target?.result === 'string' ? event.target.result : '';
      if (editorRef.current) {
        editorRef.current.focus();
       
        const container = document.createElement('div');
        container.style.position = 'relative';
        container.style.margin = '16px 0';
        container.style.textAlign = 'center';
        container.style.display = 'inline-block';
        container.style.width = '100%';
        container.className = 'video-container';
       
        const video = document.createElement('video');
        video.src = videoUrl;
        video.controls = true;
        video.style.width = '100%';
        video.style.maxWidth = '100%';
        video.style.height = 'auto';
        video.style.borderRadius = '12px';
        video.style.display = 'block';
       
        // Create remove button
        const removeBtn = document.createElement('button');
        removeBtn.innerHTML = '×';
        removeBtn.setAttribute('data-remove-media', 'true');
        removeBtn.style.position = 'absolute';
        removeBtn.style.top = '8px';
        removeBtn.style.right = '8px';
        removeBtn.style.width = '28px';
        removeBtn.style.height = '28px';
        removeBtn.style.borderRadius = '50%';
        removeBtn.style.backgroundColor = 'rgba(0, 0, 0, 0.5)';
        removeBtn.style.color = 'white';
        removeBtn.style.border = 'none';
        removeBtn.style.boxShadow = '0 2px 4px rgba(0, 0, 0, 0.15)';
        removeBtn.style.cursor = 'pointer';
        removeBtn.style.display = 'flex';
        removeBtn.style.alignItems = 'center';
        removeBtn.style.justifyContent = 'center';
        removeBtn.style.fontSize = '18px';
        removeBtn.style.fontWeight = 'normal';
        removeBtn.style.lineHeight = '1';
        removeBtn.style.opacity = '0.7';
        removeBtn.style.transition = 'opacity 0.2s ease, transform 0.2s ease, background-color 0.2s ease';
        removeBtn.style.zIndex = '99999';
        removeBtn.style.pointerEvents = 'auto';
        removeBtn.style.visibility = 'visible';
        removeBtn.onclick = (e) => {
          e.preventDefault();
          e.stopPropagation();
          const p = document.createElement('p');
          p.innerHTML = '<br>';
          if (container.parentNode) {
            container.insertAdjacentElement('afterend', p);
          } else {
            editorRef.current?.appendChild(p);
          }
          container.remove();
          const range = document.createRange();
          range.selectNodeContents(p);
          range.collapse(true);
          const selection = window.getSelection();
          if (selection) {
          selection.removeAllRanges();
          selection.addRange(range);
          }
          editorRef.current?.focus();
          updateContent();
        };
       
        container.onmouseenter = () => {
          removeBtn.style.opacity = '1';
          removeBtn.style.transform = 'scale(1.1)';
          removeBtn.style.backgroundColor = 'rgba(220, 38, 38, 0.95)'; // More visible red on hover
        };
        container.onmouseleave = () => {
          removeBtn.style.opacity = '0.7';
          removeBtn.style.transform = 'scale(1)';
          removeBtn.style.backgroundColor = 'rgba(0, 0, 0, 0.6)'; // Slightly more visible gray
        };
       
        container.appendChild(video);
        container.appendChild(removeBtn);
       
        const p = document.createElement('p');
        p.innerHTML = '<br>';
       
        const selection = window.getSelection();
        if (selection && selection.rangeCount > 0) {
          const range = selection.getRangeAt(0);
          range.deleteContents();
          range.insertNode(container);
         
          if (container.parentNode) {
            container.insertAdjacentElement('afterend', p);
        } else {
            editorRef.current.appendChild(p);
          }
         
          const newRange = document.createRange();
          newRange.selectNodeContents(p);
          newRange.collapse(true);
          selection.removeAllRanges();
          selection.addRange(newRange);
        } else {
          editorRef.current.appendChild(container);
          editorRef.current.appendChild(p);
         
          const range = document.createRange();
          range.selectNodeContents(p);
          range.collapse(true);
          const newSelection = window.getSelection();
          if (newSelection) {
            newSelection.removeAllRanges();
            newSelection.addRange(range);
          }
        }
       
        editorRef.current.focus();
        updateContent();
      }
    };
    reader.onerror = () => {
      alert('Error reading video file');
    };
    reader.readAsDataURL(file);
   
    // Reset input
    if (videoInputRef.current) {
      videoInputRef.current.value = '';
    }
    setShowVideoOptions(false);
  };

  const addTopic = () => {
    if (newTopic.trim() && !topics.includes(newTopic.trim())) {
      setTopics([...topics, newTopic.trim()]);
      setNewTopic('');
    }
  };

  const removeTopic = (topic) => {
    setTopics(topics.filter(t => t !== topic));
  };

  const extractTopics = (content) => {
    if (!content || typeof content !== 'string') return [];
    // Remove HTML tags to get plain text, then extract hashtags
    const textContent = content.replace(/<[^>]*>/g, ' ');
    // Extract hashtags from content - matches #hashtag pattern (word characters only)
    const hashtagRegex = /#(\w+)/g;
    const matches = textContent.match(hashtagRegex);
    return matches ? [...new Set(matches.map(m => m.substring(1)))] : []; // Remove duplicates
  };

  const slugify = (text) => {
    return text
      .toString()
      .toLowerCase()
      .trim()
      .replace(/\s+/g, '-')
      .replace(/[^a-z0-9-]/g, '')
      .replace(/-+/g, '-');
  };

  useEffect(() => {
    if (title) {
      const slugifiedTitle = slugify(title);
      // Update paramlink if:
      // 1. It's empty, OR
      // 2. It matches the last auto-generated paramlink (meaning it hasn't been manually edited)
      const currentParamlink = paramlink || '';
      if (!currentParamlink || currentParamlink === lastAutoGeneratedParamlinkRef.current) {
        setParamlink(slugifiedTitle);
        lastAutoGeneratedParamlinkRef.current = slugifiedTitle;
      }
    }
    // Update ref for auto-save to access latest title
    currentTitleRef.current = title;
  }, [title]);

  const showToast = (message, type = 'success') => {
    setToast({ message, type });
    setTimeout(() => {
      setToast(null);
    }, 3000);
  };

  // Prevent concurrent draft operations
  const isSavingRef = useRef(false);

  const saveDraft = async (isAutoSave = false) => {
    // Prevent multiple simultaneous save operations
    if (isSavingRef.current) {
      console.log('Save operation already in progress, skipping this request');
      return;
    }
    
    isSavingRef.current = true;
    
    try {
      // If we're editing a published blog directly and don't have a draft ID yet,
      // we should convert it to a draft first before allowing auto-save
      if (isEditingPublishedBlog && editBlogId && !currentDraftId && !editDraftId) {
        if (isAutoSave) {
          // For auto-save, just skip if we're editing a published blog without a draft
          console.log('Auto-save: Skipped - editing published blog without draft conversion');
          return;
        } else {
          // For manual save, convert the published blog to a draft first
          const draftId = await convertPublishedToDraft();
          if (!draftId) {
            // If conversion failed, show error and exit
            showToast('Failed to convert published blog to draft. Manual save failed.', 'error');
            return;
          }
        }
      }
  
    // Always capture content directly from editor DOM (most up-to-date)
    // Don't rely on state which might be stale
    let finalContent = '';
    if (editorRef.current) {
      finalContent = editorRef.current.innerHTML || '';
      // Update state with editor content to keep it in sync
      setContent(finalContent);
    } else {
      // Fallback to state if editor ref is not available
      finalContent = content || '';
    }
   
    // Determine draft ID to use (declare early to avoid temporal dead zone error)
    const draftIdToUse = currentDraftId || editDraftId;
   
    // Get current title - use ref first (most up-to-date), then fallback to state
    // The ref is updated immediately when user types, while state might lag
    const currentTitleFromRef = currentTitleRef.current?.trim() || '';
    const currentTitleFromState = title?.trim() || '';
    // Use ref value if available (more up-to-date), otherwise use state
    const currentTitle = currentTitleFromRef || currentTitleFromState;
    const currentContent = finalContent || '<p><br></p>';
   
    // Skip auto-save if no changes detected (prevents saving same content multiple times)
    if (isAutoSave) {
      // Normalize content for comparison (remove topic markers and normalize whitespace)
      const normalizeContent = (html) => {
        if (!html) return '';
        // Remove topic markers (hidden paragraphs with topics)
        let normalized = html.replace(/<p[^>]*style="display:\s*none[^"]*"[^>]*>.*?<\/p>/gi, '');
        // Normalize whitespace
        normalized = normalized.replace(/\s+/g, ' ').trim();
        return normalized;
      };
     
      const normalizedCurrentContent = normalizeContent(currentContent);
      const normalizedLastContent = normalizeContent(lastContentRef.current || '');
     
      // Compare normalized content and title
      const contentChanged = normalizedCurrentContent !== normalizedLastContent;
      const titleChanged = currentTitle.trim() !== (lastTitleRef.current || '').trim();
     
      if (!contentChanged && !titleChanged) {
        console.log('Auto-save: Skipped - no changes detected since last save', {
          currentTitle: currentTitle.trim() || 'Untitled',
          currentTitleFromRef: currentTitleFromRef.trim() || 'Empty',
          currentTitleFromState: currentTitleFromState.trim() || 'Empty',
          currentContentLength: normalizedCurrentContent.length,
          currentContentPreview: normalizedCurrentContent.substring(0, 100),
          lastSavedTitle: (lastTitleRef.current || '').trim() || 'Untitled',
          lastSavedContentLength: normalizedLastContent.length,
          lastSavedContentPreview: normalizedLastContent.substring(0, 100),
          contentChanged,
          titleChanged
        });
        return; // No changes, skip save to avoid creating duplicate drafts
      }
      console.log('Auto-save: Changes detected, proceeding with save', {
        currentTitle: currentTitle.trim() || 'Untitled',
        currentTitleFromRef: currentTitleFromRef.trim() || 'Empty',
        currentTitleFromState: currentTitleFromState.trim() || 'Empty',
        currentContentLength: normalizedCurrentContent.length,
        lastSavedTitle: (lastTitleRef.current || '').trim() || 'None',
        lastSavedContentLength: normalizedLastContent.length,
        contentChanged,
        titleChanged,
        draftId: draftIdToUse || 'new'
      });
    }
   
    // Ensure content is not empty - API requires non-empty content
    // Use minimal HTML structure if content is truly empty
    if (!finalContent || !finalContent.trim() || finalContent.trim() === '<br>' || finalContent.trim() === '<p></p>') {
      finalContent = '<p><br></p>';
    }
   
    // Determine effective title - always preserve user's title, never overwrite with "Untitled Draft"
    // Use ref value first (most up-to-date), then fallback to state
    let effectiveTitle;
   
    if (draftIdToUse) {
      // Existing draft - prioritize title from ref/state (what user typed)
      // If both are empty, use last saved title to preserve existing title
      if (currentTitle && currentTitle.trim() !== '') {
        // User has typed a title - use it
        effectiveTitle = currentTitle;
      } else if (lastTitleRef.current && lastTitleRef.current.trim() !== '' && lastTitleRef.current !== 'Untitled Draft') {
        // No title in ref/state, but we have a saved title - preserve it
        effectiveTitle = lastTitleRef.current;
      } else {
        // Truly no title exists - only then use default
        effectiveTitle = 'Untitled Draft';
      }
    } else {
      // New draft - use title from ref/state or default to "Untitled Draft"
      effectiveTitle = currentTitle || 'Untitled Draft';
    }
   
    // Final check - ensure title is not empty (API requirement)
    // But don't overwrite if user has a title
    if (!effectiveTitle || effectiveTitle.trim() === '') {
      effectiveTitle = 'Untitled Draft';
    }

    // Ensure paramlink exists by auto-generating when missing
    let effectiveParamlink = paramlink?.trim();
    if (!effectiveParamlink) {
      const base = (effectiveTitle || 'untitled').toString();
      effectiveParamlink = slugify(base).slice(0, 60) || `untitled-${Date.now()}`;
      setParamlink(effectiveParamlink);
    }

    if (!isAutoSave) {
    setIsLoading(true);
    }
   
    try {
      // Final validation - ensure all fields are non-empty (API requirement)
      if (!effectiveTitle || effectiveTitle.trim() === '') {
        effectiveTitle = 'Untitled Draft';
      }
      if (!finalContent || finalContent.trim() === '') {
        finalContent = '<p><br></p>';
      }
      if (!effectiveParamlink || effectiveParamlink.trim() === '') {
        const base = (effectiveTitle || 'untitled').toString();
        effectiveParamlink = slugify(base).slice(0, 60) || `untitled-${Date.now()}`;
        setParamlink(effectiveParamlink);
      }
     
      // Append topics as hashtags to content (hidden, so they persist and can be extracted later)
      // Extract existing topics from content BEFORE removing markers to preserve them during auto-save
      const existingTopicsFromContent = extractTopics(finalContent);
      // Merge with topics state - prioritize state, but include any from content that aren't in state
      let topicsToSave = topics && topics.length > 0 ? [...topics] : [];
      // Add any topics found in content that aren't already in the state
      if (existingTopicsFromContent && existingTopicsFromContent.length > 0) {
        existingTopicsFromContent.forEach(topic => {
          if (!topicsToSave.includes(topic)) {
            topicsToSave.push(topic);
          }
        });
      }
      // If we still have no topics but found some in content, use those
      if (topicsToSave.length === 0 && existingTopicsFromContent && existingTopicsFromContent.length > 0) {
        topicsToSave = existingTopicsFromContent;
      }
     
      // Update topics state if we found topics in content that weren't in state (keeps UI in sync)
      if (topicsToSave.length > 0 && (!topics || topics.length === 0 || topicsToSave.length !== topics.length)) {
        // Only update if there's a meaningful difference to avoid unnecessary re-renders
        const stateTopicsSet = new Set(topics || []);
        const topicsToSaveSet = new Set(topicsToSave);
        const hasDifference = topicsToSaveSet.size !== stateTopicsSet.size ||
                             !Array.from(topicsToSaveSet).every(t => stateTopicsSet.has(t));
        if (hasDifference) {
          setTopics(topicsToSave);
        }
      }
     
      // Remove existing topic markers first to avoid duplicates
      let contentWithTopics = finalContent;
      const topicMarkerRegex = /<p[^>]*style="display:\s*none[^"]*"[^>]*>.*?<\/p>/gi;
      contentWithTopics = contentWithTopics.replace(topicMarkerRegex, '');
     
      // Always add topics back if we have any (preserves hashtags during auto-save)
      if (topicsToSave && topicsToSave.length > 0) {
        const topicsAsHashtags = topicsToSave.map(t => `#${t}`).join(' ');
        // Append topics as hidden paragraph so they're preserved in content but not visible
        contentWithTopics += `<p style="display:none;visibility:hidden;">${topicsAsHashtags}</p>`;
      }
     
      const draftData = {
        title: effectiveTitle.trim(),
        content: contentWithTopics,
        paramlink: effectiveParamlink.trim(),
        isAutoSave: isAutoSave, // Pass auto-save flag to API
      };
     
      // Don't update title state after saving - preserve what user has typed
      // The title state should only be updated by user input, not by save operation

      let response;
     
      // Add timeout to prevent hanging requests
      const axiosConfig = {
        ...getAuthHeaders(),
        timeout: 30000, // 30 seconds timeout
      };
     
      if (draftIdToUse) {
        // Update existing draft
        console.log('Auto-save: Calling API to UPDATE draft', {
          draftId: draftIdToUse,
          title: effectiveTitle.substring(0, 50),
          contentLength: contentWithTopics.length
        });
        response = await axios.put(
          `/api/blog/draft?id=${draftIdToUse}`,
          draftData,
          axiosConfig
        );
        console.log('Auto-save: API response received (UPDATE)', {
          success: response.data?.success,
          draftId: response.data?.draft?._id
        });
      } else {
        // Create new draft
        console.log('Auto-save: Calling API to CREATE new draft', {
          title: effectiveTitle.substring(0, 50),
          contentLength: contentWithTopics.length
        });
        try {
          response = await axios.post('/api/blog/draft', draftData, axiosConfig);
        } catch (createErr) {
          // 409 means the paramlink conflicts with a published blog.
          // Auto-fix by generating a unique paramlink and retry once.
          if (createErr?.response?.status === 409) {
            const suffix = Date.now().toString().slice(-6);
            const nextParamlink = `${draftData.paramlink}-${suffix}`.slice(0, 80);
            console.warn('Draft create conflict (409). Retrying with new paramlink:', nextParamlink);
            setParamlink(nextParamlink);
            // Prevent auto-title slug effect from immediately overriding our fix
            lastAutoGeneratedParamlinkRef.current = nextParamlink;
            response = await axios.post(
              '/api/blog/draft',
              { ...draftData, paramlink: nextParamlink },
              axiosConfig
            );
          } else {
            throw createErr;
          }
        }
        console.log('Auto-save: API response received (CREATE)', {
          success: response.data?.success,
          draftId: response.data?.draft?._id
        });
        // Save the draft ID for future updates
        if (response.data?.success && response.data?.draft?._id) {
          setCurrentDraftId(response.data.draft._id);
          console.log('Auto-save: Draft ID saved for future updates', response.data.draft._id);
        }
      }
     
      // Update last saved content and title
      lastContentRef.current = finalContent;
      lastTitleRef.current = effectiveTitle;
      setLastSaved(new Date());
     
      if (isAutoSave) {
        showToast('Draft auto-saved', 'success');
      } else {
        showToast('Draft saved successfully!', 'success');
      }
    } catch (error) {
      console.error('Error saving draft:', error);
      console.error('Draft data sent:', {
        title: effectiveTitle,
        contentLength: finalContent.length,
        paramlink: effectiveParamlink,
        draftId: draftIdToUse
      });
     
      let errorMessage = 'Failed to save draft';
      if (error.code === 'ECONNABORTED' || error.message?.includes('timeout')) {
        // Request timeout
        errorMessage = 'Request timed out. Please check your connection and try again.';
        console.error('Request timeout:', error);
      } else if (error.response) {
        // Server responded with error
        errorMessage = error.response.data?.message || error.response.data?.error || `Server error: ${error.response.status}`;
        console.error('Server error response:', error.response.data);
      } else if (error.request) {
        // Request was made but no response received
        errorMessage = 'Network error: Unable to connect to server. Please check your internet connection.';
        console.error('Network error - no response:', error.request);
      } else {
        // Something else happened
        errorMessage = error.message || 'Unknown error occurred';
        console.error('Error setting up request:', error.message);
      }
     
      if (isAutoSave) {
        showToast('Auto-save failed', 'error');
      } else {
        showToast(errorMessage, 'error');
      }
    } finally {
      // Always release the lock
      isSavingRef.current = false;
      
      if (!isAutoSave) {
        setIsLoading(false);
      }
    }
  };

  // Function to convert a published blog to a draft when editing
  const convertPublishedToDraft = async () => {
    // Prevent concurrent conversion operations
    if (isSavingRef.current) {
      console.log('Conversion already in progress, skipping this request');
      return null;
    }
    
    isSavingRef.current = true;
    
    if (!editBlogId || !isEditingPublishedBlog) {
      isSavingRef.current = false;
      return null;
    }
    
    try {
      // Create a draft from the current published blog data
      let effectiveContent = '';
      if (editorRef.current) {
        effectiveContent = editorRef.current.innerHTML || '';
        setContent(effectiveContent);
      } else {
        effectiveContent = content || '<p><br></p>';
      }
      
      // Get current title - use ref first (most up-to-date), then fallback to state
      const currentTitleFromRef = currentTitleRef.current?.trim() || '';
      const currentTitleFromState = title?.trim() || '';
      const currentTitle = currentTitleFromRef || currentTitleFromState;

      // Ensure paramlink exists
      let effectiveParamlink = paramlink?.trim();
      if (!effectiveParamlink) {
        const base = (currentTitle || 'untitled').toString();
        effectiveParamlink = slugify(base).slice(0, 60) || `untitled-${Date.now()}`;
        setParamlink(effectiveParamlink);
      }

      // Append topics as hashtags to content (hidden, so they persist and can be extracted later)
      let contentWithTopics = effectiveContent;
      // Remove existing topic markers first to avoid duplicates
      const topicMarkerRegex = /<p[^>]*style="display:\s*none[^"]*"[^>]*>.*?<\/p>/gi;
      contentWithTopics = contentWithTopics.replace(topicMarkerRegex, '');
     
      if (topics && topics.length > 0) {
        const topicsAsHashtags = topics.map(t => `#${t}`).join(' ');
        // Append topics as hidden paragraph so they're preserved in content but not visible
        contentWithTopics += `<p style="display:none;visibility:hidden;">${topicsAsHashtags}</p>`;
      }

      const draftData = {
        title: currentTitle || 'Untitled Draft',
        content: contentWithTopics,
        paramlink: effectiveParamlink,
      };

      // Create a new draft from the published blog
      const response = await axios.post('/api/blog/draft', draftData, getAuthHeaders());
      
      if (response.data?.success && response.data?.draft?._id) {
        // Set the current draft ID so auto-save will work properly
        setCurrentDraftId(response.data.draft._id);
        setIsEditingPublishedBlog(false); // No longer editing published blog directly
        
        console.log('Converted published blog to draft successfully', response.data.draft._id);
        return response.data.draft._id;
      }
      
      return null;
    } catch (error) {
      console.error('Error converting published blog to draft:', error);
      const errorMessage = error.response?.data?.message || error.response?.data?.error || 'Failed to convert to draft';
      showToast(`Failed to convert to draft: ${errorMessage}`, 'error');
      return null;
    } finally {
      // Always release the lock
      isSavingRef.current = false;
    }
  };

  const publishBlog = async () => {
    if (!title || !content) {
      alert('Title and content are required');
      return;
    }

    // If we're editing a published blog directly, convert it to draft first to avoid conflicts
    if (isEditingPublishedBlog && editBlogId && !currentDraftId) {
      const draftId = await convertPublishedToDraft();
      if (!draftId) {
        // If conversion failed, show error and exit
        alert('Failed to prepare draft for editing. Please try again.');
        return;
      }
    }

    // Ensure paramlink exists by auto-generating when missing
    let effectiveParamlink = paramlink?.trim();
    if (!effectiveParamlink) {
      const base = (title || 'untitled').toString();
      effectiveParamlink = slugify(base).slice(0, 60) || `untitled-${Date.now()}`;
      setParamlink(effectiveParamlink);
    }

    setIsPublishing(true);
    try {
      // Append topics as hashtags to content (hidden, so they persist and can be extracted later)
      let publishContent = content.trim();
      // Remove existing topic markers first to avoid duplicates
      const topicMarkerRegex = /<p[^>]*style="display:\s*none[^"]*"[^>]*>.*?<\/p>/gi;
      publishContent = publishContent.replace(topicMarkerRegex, '');
     
      if (topics && topics.length > 0) {
        const topicsAsHashtags = topics.map(t => `#${t}`).join(' ');
        // Append topics as hidden paragraph so they're preserved in content but not visible
        publishContent += `<p style="display:none;visibility:hidden;">${topicsAsHashtags}</p>`;
      }
     
      const publishData = {
        title: title.trim(),
        content: publishContent,
        paramlink: effectiveParamlink,
      };

      if (editBlogId) {
        // Updating an existing published blog
        await axios.put(
          `/api/blog/published?id=${editBlogId}`,
          publishData,
          getAuthHeaders()
        );
      } else if (editDraftId || currentDraftId) {
        // If publishing from a draft, update the draft's status to published via POST with draftId
        const draftIdToPublish = editDraftId || currentDraftId;
        await axios.post(
          `/api/blog/published?draftId=${draftIdToPublish}`,
          publishData,
          getAuthHeaders()
        );
      } else {
        // Creating a new published blog
        await axios.post(
          '/api/blog/published',
          publishData,
          getAuthHeaders()
        );
      }
      if (onSave) onSave(true);
      if (onClose) onClose();
    } catch (error) {
      console.error('Error publishing blog:', error);
      const errorMessage = error.response?.data?.message || error.response?.data?.error || 'Failed to publish blog';
      alert(errorMessage);
    } finally {
      setIsPublishing(false);
    }
  };

  return (
    <div className="force-light fixed inset-0 z-50 flex items-center justify-center bg-black/60 backdrop-blur-sm p-2 sm:p-4">
      {/* Video Options Modal */}
      {showVideoOptions && (
        <div className="fixed inset-0 z-[70] flex items-center justify-center bg-black/60 backdrop-blur-sm p-2 sm:p-4" onClick={() => setShowVideoOptions(false)}>
          <div className="bg-white rounded-xl sm:rounded-2xl shadow-2xl p-4 sm:p-5 md:p-6 max-w-md w-full mx-2 sm:mx-4" onClick={(e) => e.stopPropagation()}>
            <div className="flex items-center justify-between mb-3 sm:mb-4">
              <h3 className="text-lg sm:text-xl font-semibold text-gray-900">Add Video</h3>
              <button
                onClick={() => setShowVideoOptions(false)}
                className="p-1.5 sm:p-2 hover:bg-gray-100 rounded-lg transition-colors"
              >
                <X className="w-4 h-4 sm:w-5 sm:h-5 text-gray-600" />
              </button>
            </div>
            <div className="space-y-2 sm:space-y-3">
              <button
                onClick={() => {
                  videoInputRef.current?.click();
                }}
                className="w-full flex items-center gap-2 sm:gap-3 p-3 sm:p-4 border-2 border-gray-200 rounded-lg sm:rounded-xl hover:border-cyan-500 hover:bg-cyan-50 transition-all group"
              >
                <div className="w-10 h-10 sm:w-12 sm:h-12 bg-gradient-to-br from-cyan-500 to-teal-500 rounded-lg flex items-center justify-center group-hover:scale-110 transition-transform flex-shrink-0">
                  <Video className="w-5 h-5 sm:w-6 sm:h-6 text-white" />
            </div>
                <div className="text-left min-w-0 flex-1">
                  <div className="text-sm sm:text-base font-semibold text-gray-900">Upload Video</div>
                  <div className="text-xs sm:text-sm text-gray-500">Upload a video file from your device</div>
          </div>
              </button>
              <button
                onClick={() => {
                  setShowVideoOptions(false);
                  const url = prompt('Enter video URL (YouTube, Vimeo, Dailymotion, or direct video link):');
                  if (url && url.trim()) {
                    insertVideoFromUrl(url);
                  }
                }}
                className="w-full flex items-center gap-2 sm:gap-3 p-3 sm:p-4 border-2 border-gray-200 rounded-lg sm:rounded-xl hover:border-cyan-500 hover:bg-cyan-50 transition-all group"
              >
                <div className="w-10 h-10 sm:w-12 sm:h-12 bg-gradient-to-br from-blue-500 to-cyan-500 rounded-lg flex items-center justify-center group-hover:scale-110 transition-transform flex-shrink-0">
                  <LinkIcon className="w-5 h-5 sm:w-6 sm:h-6 text-white" />
                </div>
                <div className="text-left min-w-0 flex-1">
                  <div className="text-sm sm:text-base font-semibold text-gray-900">Add URL</div>
                  <div className="text-xs sm:text-sm text-gray-500">Paste a video link (YouTube, Vimeo, etc.)</div>
                </div>
              </button>
            </div>
          </div>
        </div>
      )}

      {/* Toaster Notification */}
      {toast && (
        <div className="fixed top-2 sm:top-4 right-2 sm:right-4 left-2 sm:left-auto z-[60] animate-in slide-in-from-top-5 max-w-sm sm:max-w-none">
          <div className={`px-4 sm:px-6 py-2.5 sm:py-3 rounded-lg shadow-lg flex items-center gap-2 sm:gap-3 text-sm sm:text-base ${
            toast.type === 'success'
              ? 'bg-green-500 text-white'
              : 'bg-red-500 text-white'
          }`}>
            <span className="flex-1 break-words">{toast.message}</span>
            <button
              onClick={() => setToast(null)}
              className="ml-1 sm:ml-2 hover:opacity-70 flex-shrink-0"
            >
              <X className="w-4 h-4" />
            </button>
          </div>
        </div>
      )}

      <style jsx global>{`
        /* === Content Editor Base Styles === */
        [contenteditable="true"],
        [contenteditable] {
          /* List styles */
          ul, ol {
            margin: 1rem 0 !important;
            padding-left: 2rem !important;
            list-style-position: outside !important;
            display: block !important;
          }
          
          ul { list-style-type: disc !important; }
          ol { list-style-type: decimal !important; }
          
          li {
            display: list-item !important;
            margin: 0.5rem 0 !important;
          }
          
          /* Heading styles */
          h1, h2, h3, h4, h5, h6 {
            display: block !important;
            font-weight: bold !important;
            margin: 1rem 0 !important;
          }
          
          h1 { font-size: 2em !important; }
          h2 { font-size: 1.5em !important; }
          h3 { font-size: 1.17em !important; }
          
          /* Blockquote styles */
          blockquote {
            display: block !important;
            margin: 1rem 0 !important;
            padding-left: 1rem !important;
            border-left: 3px solid #9333ea !important;
          }
          
          /* Paragraph styles */
          p {
            display: block !important;
            margin: 1rem 0 !important;
          }
          
          /* Link styles */
          a {
            color: #2563eb !important;
            text-decoration: underline !important;
            text-decoration-color: #2563eb !important;
            text-underline-offset: 2px !important;
            cursor: pointer !important;
          }
          
          a:hover {
            color: #1d4ed8 !important;
            text-decoration-color: #1d4ed8 !important;
          }
          
          a:visited {
            color: #7c3aed !important;
            text-decoration-color: #7c3aed !important;
          }
        }
        
        /* === Prose Override Styles === */
        .prose [contenteditable="true"],
        .prose [contenteditable] {
          ul, ol {
            list-style-type: inherit !important;
            padding-left: 2rem !important;
            margin: 1rem 0 !important;
          }
          
          li { display: list-item !important; }
        }
        
        /* === Preview Content Styles === */
        .preview-content {
          ul, ol {
            margin: 1rem 0 !important;
            padding-left: 2rem !important;
            list-style-position: outside !important;
            display: block !important;
          }
          
          ul { list-style-type: disc !important; }
          ol { list-style-type: decimal !important; }
          
          li {
            display: list-item !important;
            margin: 0.5rem 0 !important;
          }
          
          h1, h2, h3, h4, h5, h6 {
            display: block !important;
            font-weight: bold !important;
            margin: 1rem 0 !important;
          }
          
          h1 { font-size: 2em !important; }
          h2 { font-size: 1.5em !important; }
          h3 { font-size: 1.17em !important; }
          
          blockquote {
            display: block !important;
            margin: 1rem 0 !important;
            padding-left: 1rem !important;
            border-left: 3px solid #9333ea !important;
          }
          
          p {
            display: block !important;
            margin: 1rem 0 !important;
          }
        }
        
        /* === Prose Override for Preview === */
        .preview-content.prose {
          ul, ol {
            list-style-type: inherit !important;
            padding-left: 2rem !important;
            margin: 1rem 0 !important;
          }
          
          li { display: list-item !important; }
        }
        
        /* === Media Container Styles === */
        .image-container,
        .video-container {
          position: relative !important;
          overflow: visible !important;
          z-index: auto !important;
          display: block !important;
          text-align: center !important;
        }
        
        .image-container img,
        .video-container video,
        .video-container iframe {
          display: block !important;
          margin: 0 auto !important;
          max-width: 70% !important;
          width: auto !important;
          height: auto !important;
          max-height: 360px !important;
          border-radius: 12px !important;
          object-fit: cover !important;
        }
        
        @media (max-width: 768px) {
          .image-container img,
          .video-container video,
          .video-container iframe {
            max-width: 95% !important;
            max-height: 280px !important;
          }
        }
        
        .image-container button[data-remove-media="true"],
        .video-container button[data-remove-media="true"] {
          position: absolute !important;
          z-index: 99999 !important;
          display: flex !important;
          visibility: visible !important;
          pointer-events: auto !important;
        }
        
        /* Ensure prose class doesn't hide buttons */
        .prose .image-container,
        .prose .video-container {
          overflow: visible !important;
        }
        
        .prose .image-container button,
        .prose .video-container button {
          z-index: 99999 !important;
        }
        
        /* Hide remove buttons in preview section */
        .preview-content .image-container button[data-remove-media="true"],
        .preview-content .video-container button[data-remove-media="true"],
        .preview-content button[data-remove-media="true"] {
          display: none !important;
          visibility: hidden !important;
          opacity: 0 !important;
        }
        
        /* === Force Light Theme === */
        .force-light,
        .force-light * {
          color-scheme: light !important;
        }
        
        .force-light [contenteditable="true"],
        .force-light [contenteditable] {
          color: #171717 !important;
          background-color: #ffffff !important;
        }
        
        .force-light .text-gray-600,
        .force-light .text-gray-700,
        .force-light .text-gray-900 {
          color: #171717 !important;
        }
        
        .force-light .bg-gray-50,
        .force-light .bg-white {
          background-color: #ffffff !important;
        }
        
        /* === Toolbar Responsive Styles === */
        .toolbar-responsive {
          flex-wrap: wrap;
        }
        
        .toolbar-responsive > * {
          margin-bottom: 0.25rem;
        }
        
        @media (max-width: 640px) {
          .toolbar-responsive {
            gap: 0.25rem;
          }
          
          .toolbar-button {
            padding: 0.25rem;
            margin: 0 0.125rem;
          }
          
          .toolbar-divider {
            height: 1rem;
            margin: 0 0.125rem;
          }
        }
        
        /* === Hashtag Section Styles === */
        .hashtags-section {
          padding-top: 0.5rem;
          padding-bottom: 0.25rem;
          padding-left: 0.75rem;
          padding-right: 0.75rem;
        }
        
        @media (min-width: 640px) {
          .hashtags-section {
            padding-left: 1rem;
            padding-right: 1rem;
          }
        }
        
        .hashtags-container {
          gap: 0.25rem;
          margin-bottom: 0.25rem;
        }
        
        .hashtag-tag {
          padding: 0.125rem 0.25rem;
          margin-right: 0.125rem;
          margin-bottom: 0.125rem;
        }
        
        .hashtag-input-section {
          gap: 0.25rem;
        }
        
        @media (max-width: 768px) {
          .hashtags-section {
            padding-top: 0.25rem;
            padding-bottom: 0.125rem;
            padding-left: 0.75rem;
            padding-right: 0.75rem;
          }
          
          .hashtags-container {
            gap: 0.125rem;
            margin-bottom: 0.125rem;
          }
          
          .hashtag-tag {
            padding: 0.0625rem 0.125rem;
            margin-right: 0.0625rem;
            margin-bottom: 0.0625rem;
          }
          
          .hashtag-input-section {
            gap: 0.125rem;
          }
        }
        
        @media (max-width: 640px) {
          .hashtags-section {
            padding-top: 0.125rem;
            padding-bottom: 0.0625rem;
            padding-left: 0.75rem;
            padding-right: 0.75rem;
          }
          
          .hashtags-label {
            margin-bottom: 0.0625rem;
            font-size: 0.75rem;
          }
          
          .hashtags-container {
            gap: 0.0625rem;
            margin-bottom: 0.0625rem;
          }
          
          .hashtag-tag {
            padding: 0.03125rem 0.125rem;
            font-size: 0.75rem;
            gap: 0.0625rem;
            margin-right: 0.03125rem;
            margin-bottom: 0.03125rem;
          }
          
          .hashtag-input-section {
            gap: 0.0625rem;
          }
          
          .hashtag-input {
            padding: 0.0625rem 0.125rem;
            font-size: 0.75rem;
          }
          
          .hashtag-add-btn {
            padding: 0.0625rem 0.125rem;
          }
        }
      `}</style>

      <div className="bg-white rounded-xl sm:rounded-2xl md:rounded-3xl shadow-2xl w-full max-w-6xl h-[95vh] sm:h-[90vh] flex flex-col overflow-hidden">
        {/* Header - Compact */}
        <div className="flex items-center justify-between px-3 sm:px-4 py-2 sm:py-3 border-b border-gray-200 flex-shrink-0">
          <h2 className="text-base sm:text-lg font-semibold text-gray-900 truncate">
            {editBlogId || editDraftId ? 'Edit Post' : 'New Post'}
          </h2>
          <div className="flex items-center gap-1.5 sm:gap-2 flex-shrink-0">
            <button
              onClick={() => setShowPreview(!showPreview)}
              className="p-1.5 sm:p-2 hover:bg-gray-100 rounded-lg transition-colors"
              title="Preview"
            >
              <Eye className="w-3.5 h-3.5 sm:w-4 sm:h-4 text-gray-600" />
            </button>
            <button
              onClick={onClose}
              className="p-1.5 sm:p-2 hover:bg-gray-100 rounded-lg transition-colors"
            >
              <X className="w-3.5 h-3.5 sm:w-4 sm:h-4 text-gray-600" />
            </button>
          </div>
        </div>

        {/* Title at Top */}
        <div className="px-3 sm:px-4 md:px-6 py-3 sm:py-4 border-b border-gray-200 flex-shrink-0">
          <div className="flex flex-col md:flex-row items-start gap-3 sm:gap-4">
            {/* Title Input - Left Side */}
            <div className="flex-1 w-full min-w-0">
              <input
                type="text"
                placeholder="Title..."
                value={title}
                onChange={(e) => {
                  const newTitle = e.target.value;
                  setTitle(newTitle);
                  currentTitleRef.current = newTitle; // Update ref immediately
                  markTypingActivity(); // Track typing activity
                }}
                className="w-full text-lg sm:text-xl md:text-2xl lg:text-3xl font-bold border-none outline-none placeholder-gray-400"
              />
            </div>
            {/* URL Slug - Right Side */}
            <div className="w-full md:w-72 lg:w-80 flex-shrink-0">
              <label className="block text-xs font-semibold text-gray-600 mb-1 sm:mb-1.5">
                URL Slug
              </label>
              <div className="flex items-center gap-1.5 sm:gap-2">
                <span className="text-xs sm:text-sm text-gray-500 whitespace-nowrap flex-shrink-0">/blogs/</span>
                <input
                  type="text"
                  value={paramlink}
                  onChange={(e) => {
                    const newParamlink = slugify(e.target.value);
                    setParamlink(newParamlink);
                    // Mark as manually edited by setting ref to a value that won't match auto-generated
                    // This prevents title changes from overwriting manual edits
                    lastAutoGeneratedParamlinkRef.current = '';
                    markTypingActivity(); // Track typing activity
                  }}
                  placeholder="blog-url-slug"
                  className="flex-1 min-w-0 px-2 sm:px-3 py-1 sm:py-1.5 text-xs sm:text-sm border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-cyan-500"
                />
              </div>
            </div>
          </div>
        </div>

        <div className="flex-grow overflow-hidden flex flex-col md:flex-row relative min-h-0">
          {/* Main Editor */}
          <div className={`flex-grow flex flex-col min-h-0 ${showPreview ? 'md:w-1/2' : 'w-full'} transition-all duration-300 relative`} style={{ overflow: 'visible' }}>
            {/* Floating Toolbar in Corner */}
            <div className="absolute top-1 right-1 sm:top-2 sm:right-2 md:top-3 md:right-3 lg:top-4 lg:right-4 z-[100]" style={{ position: 'absolute', pointerEvents: 'auto' }}>
              <div className="relative">
                {/* Plus Button */}
                <button
                  onClick={() => setShowToolbar(!showToolbar)}
                  className="w-8 h-8 sm:w-10 sm:h-10 md:w-11 md:h-11 lg:w-12 lg:h-12 bg-gradient-to-br from-cyan-500 to-teal-500 hover:from-cyan-600 hover:to-teal-600 text-white rounded-full shadow-lg flex items-center justify-center transition-all transform hover:scale-110"
                  title="Formatting Options"
                  type="button"
                >
                  <Plus className={`w-4 h-4 sm:w-5 sm:h-5 md:w-5 md:h-5 lg:w-6 lg:h-6 transition-transform ${showToolbar ? 'rotate-45' : ''}`} />
                </button>
               
                {/* Expanded Toolbar */}
                {showToolbar && (
                  <div
                    className="absolute top-10 sm:top-12 md:top-14 right-0 bg-white rounded-lg sm:rounded-xl shadow-2xl border-2 border-gray-300 p-2 sm:p-3 z-[100] min-w-[180px] max-h-[300px] overflow-y-auto"
                    style={{
                      position: 'absolute',
                      pointerEvents: 'auto',
                      visibility: 'visible',
                      opacity: 1,
                      display: 'block',
                      backgroundColor: 'white'
                    }}
                    onClick={(e) => e.stopPropagation()}
                  >
                    <div className="grid grid-cols-3 gap-1.5 sm:gap-2">
                      {/* Media - Icons only, no labels */}
                      <button
                        onClick={(e) => {
                          e.preventDefault();
                          e.stopPropagation();
                          fileInputRef.current?.click();
                          setShowToolbar(false);
                        }}
                        className="p-2.5 hover:bg-gray-100 rounded-lg transition-colors flex items-center justify-center text-gray-700 hover:text-gray-900"
                        title="Insert Image"
                        type="button"
                      >
                        <ImageIcon className="w-4 h-4 text-current" />
                      </button>
                      <button
                        onClick={(e) => {
                          e.preventDefault();
                          e.stopPropagation();
                          setShowVideoOptions(true);
                          setShowToolbar(false);
                        }}
                        className="p-2.5 hover:bg-gray-100 rounded-lg transition-colors flex items-center justify-center text-gray-700 hover:text-gray-900"
                        title="Insert Video"
                        type="button"
                      >
                        <Video className="w-4 h-4 text-current" />
                      </button>
                      <button
                        onClick={(e) => {
                          e.preventDefault();
                          e.stopPropagation();
                          const selection = window.getSelection();
                          if (!selection || selection.rangeCount === 0 || selection.toString().trim() === '') {
                            alert('Please select text to create a link');
                            setShowToolbar(false);
                            return;
                          }
                                         
                          const url = prompt('Enter link URL:', 'https://');
                          if (url && url.trim()) {
                            if (!url.startsWith('http://') && !url.startsWith('https://')) {
                              formatText('createLink', `https://${url}`);
                            } else {
                              formatText('createLink', url);
                            }
                          }
                          setShowToolbar(false);
                        }}
                       className="p-2.5 hover:bg-gray-100 rounded-lg transition-colors flex items-center justify-center text-gray-700 hover:text-gray-900"
                        title="Insert Link"
                        type="button"
                      >
                        <LinkIcon className="w-4 h-4 text-current" />
                      </button>
                                      
                      {/* Text Format - Icons only */}
                      <button
                        onClick={(e) => {
                          e.preventDefault();
                          e.stopPropagation();
                          formatText('bold');
                          setShowToolbar(false);
                        }}
                        className={`p-2.5 rounded-lg transition-colors flex items-center justify-center ${
                          activeFormats.has('bold')
                            ? 'bg-cyan-100 text-cyan-700'
                            : 'hover:bg-gray-100 text-gray-700 hover:text-gray-900'
                        }`}
                        title="Bold"
                        type="button"
                      >
                        <Bold className="w-4 h-4 text-current" />
                      </button>
                      <button
                        onClick={(e) => {
                          e.preventDefault();
                          e.stopPropagation();
                          formatText('italic');
                          setShowToolbar(false);
                        }}
                        className={`p-2.5 rounded-lg transition-colors flex items-center justify-center ${
                          activeFormats.has('italic')
                            ? 'bg-cyan-100 text-cyan-700'
                            : 'hover:bg-gray-100 text-gray-700 hover:text-gray-900'
                        }`}
                        title="Italic"
                        type="button"
                      >
                        <Italic className="w-4 h-4 text-current" />
                      </button>
                      <button
                        onClick={(e) => {
                          e.preventDefault();
                          e.stopPropagation();
                          formatText('underline');
                          setShowToolbar(false);
                        }}
                        className={`p-2.5 rounded-lg transition-colors flex items-center justify-center ${
                          activeFormats.has('underline')
                            ? 'bg-cyan-100 text-cyan-700'
                            : 'hover:bg-gray-100 text-gray-700 hover:text-gray-900'
                        }`}
                        title="Underline"
                        type="button"
                      >
                        <Underline className="w-4 h-4 text-current" />
                      </button>
                                      
                      {/* Advanced Formatting */}
                      <button
                        onClick={(e) => {
                          e.preventDefault();
                          e.stopPropagation();
                          formatText('strikeThrough');
                          setShowToolbar(false);
                        }}
                        className={`p-2.5 rounded-lg transition-colors flex items-center justify-center ${
                          activeFormats.has('strikeThrough')
                            ? 'bg-cyan-100 text-cyan-700'
                            : 'hover:bg-gray-100 text-gray-700 hover:text-gray-900'
                        }`}
                        title="Strikethrough"
                        type="button"
                      >
                        <Strikethrough className="w-4 h-4 text-current" />
                      </button>
                      <button
                        onClick={(e) => {
                          e.preventDefault();
                          e.stopPropagation();
                          formatText('formatBlock', '<pre>');
                          setShowToolbar(false);
                        }}
                        className={`p-2.5 rounded-lg transition-colors flex items-center justify-center ${
                          activeFormats.has('pre')
                            ? 'bg-cyan-100 text-cyan-700'
                            : 'hover:bg-gray-100 text-gray-700 hover:text-gray-900'
                        }`}
                        title="Code Block"
                        type="button"
                      >
                        <Code className="w-4 h-4 text-current" />
                      </button>
                      <button
                        onClick={(e) => {
                          e.preventDefault();
                          e.stopPropagation();
                          formatText('insertHorizontalRule');
                          setShowToolbar(false);
                        }}
                        className="p-2.5 hover:bg-gray-100 rounded-lg transition-colors flex items-center justify-center text-gray-700 hover:text-gray-900"
                        title="Horizontal Rule"
                        type="button"
                      >
                        <Minus className="w-4 h-4 text-current" />
                      </button>
                                      
                      {/* Headings - Icons only */}
                      <button
                        onClick={(e) => {
                          e.preventDefault();
                          e.stopPropagation();
                          formatText('formatBlock', '<h1>');
                          setShowToolbar(false);
                        }}
                        className={`p-2.5 rounded-lg transition-colors flex items-center justify-center ${
                          activeFormats.has('h1')
                            ? 'bg-cyan-100 text-cyan-700'
                            : 'hover:bg-gray-100 text-gray-700 hover:text-gray-900'
                        }`}
                        title="Heading 1"
                        type="button"
                      >
                        <Heading1 className="w-4 h-4 text-current" />
                      </button>
                      <button
                        onClick={(e) => {
                          e.preventDefault();
                          e.stopPropagation();
                          formatText('formatBlock', '<h2>');
                          setShowToolbar(false);
                        }}
                        className={`p-2.5 rounded-lg transition-colors flex items-center justify-center ${
                          activeFormats.has('h2')
                            ? 'bg-cyan-100 text-cyan-700'
                            : 'hover:bg-gray-100 text-gray-700 hover:text-gray-900'
                        }`}
                        title="Heading 2"
                        type="button"
                      >
                        <Heading2 className="w-4 h-4 text-current" />
                      </button>
                      <button
                        onClick={(e) => {
                          e.preventDefault();
                          e.stopPropagation();
                          formatText('formatBlock', '<h3>');
                          setShowToolbar(false);
                        }}
                        className={`p-2.5 rounded-lg transition-colors flex items-center justify-center ${
                          activeFormats.has('h3')
                            ? 'bg-cyan-100 text-cyan-700'
                            : 'hover:bg-gray-100 text-gray-700 hover:text-gray-900'
                        }`}
                        title="Heading 3"
                        type="button"
                      >
                        <Heading3 className="w-4 h-4 text-current" />
                      </button>
                                      
                      {/* Alignment - Icons only */}
                      <button
                        onClick={(e) => {
                          e.preventDefault();
                          e.stopPropagation();
                          formatText('justifyLeft');
                          setShowToolbar(false);
                        }}
                        className={`p-2.5 rounded-lg transition-colors flex items-center justify-center ${
                          activeFormats.has('justifyLeft')
                            ? 'bg-cyan-100 text-cyan-700'
                            : 'hover:bg-gray-100 text-gray-700 hover:text-gray-900'
                        }`}
                        title="Align Left"
                        type="button"
                      >
                        <AlignLeft className="w-4 h-4 text-current" />
                      </button>
                      <button
                        onClick={(e) => {
                          e.preventDefault();
                          e.stopPropagation();
                          formatText('justifyCenter');
                          setShowToolbar(false);
                        }}
                        className={`p-2.5 rounded-lg transition-colors flex items-center justify-center ${
                          activeFormats.has('justifyCenter')
                            ? 'bg-cyan-100 text-cyan-700'
                            : 'hover:bg-gray-100 text-gray-700 hover:text-gray-900'
                        }`}
                        title="Align Center"
                        type="button"
                      >
                        <AlignCenter className="w-4 h-4 text-current" />
                      </button>
                      <button
                        onClick={(e) => {
                          e.preventDefault();
                          e.stopPropagation();
                          formatText('justifyRight');
                          setShowToolbar(false);
                        }}
                        className={`p-2.5 rounded-lg transition-colors flex items-center justify-center ${
                          activeFormats.has('justifyRight')
                            ? 'bg-cyan-100 text-cyan-700'
                            : 'hover:bg-gray-100 text-gray-700 hover:text-gray-900'
                        }`}
                        title="Align Right"
                        type="button"
                      >
                        <AlignRight className="w-4 h-4 text-current" />
                      </button>
                                      
                      {/* Indentation */}
                      <button
                        onClick={(e) => {
                          e.preventDefault();
                          e.stopPropagation();
                          formatText('indent');
                          setShowToolbar(false);
                        }}
                        className="p-2.5 hover:bg-gray-100 rounded-lg transition-colors flex items-center justify-center text-gray-700 hover:text-gray-900"
                        title="Indent"
                        type="button"
                      >
                        <IndentIncrease className="w-4 h-4 text-current" />
                      </button>
                      <button
                        onClick={(e) => {
                          e.preventDefault();
                          e.stopPropagation();
                          formatText('outdent');
                          setShowToolbar(false);
                        }}
                        className="p-2.5 hover:bg-gray-100 rounded-lg transition-colors flex items-center justify-center text-gray-700 hover:text-gray-900"
                        title="Outdent"
                        type="button"
                      >
                        <IndentDecrease className="w-4 h-4 text-current" />
                      </button>
                                      
                      {/* Lists & More - Icons only */}
                      <button
                        onClick={(e) => {
                          e.preventDefault();
                          e.stopPropagation();
                          formatText('insertUnorderedList');
                          setShowToolbar(false);
                        }}
                        className={`p-2.5 rounded-lg transition-colors flex items-center justify-center ${
                          activeFormats.has('insertUnorderedList')
                            ? 'bg-cyan-100 text-cyan-700'
                            : 'hover:bg-gray-100 text-gray-700 hover:text-gray-900'
                        }`}
                        title="Bullet List"
                        type="button"
                      >
                        <List className="w-4 h-4 text-current" />
                      </button>
                      <button
                        onClick={(e) => {
                          e.preventDefault();
                          e.stopPropagation();
                          formatText('insertOrderedList');
                          setShowToolbar(false);
                        }}
                        className={`p-2.5 rounded-lg transition-colors flex items-center justify-center ${
                          activeFormats.has('insertOrderedList')
                            ? 'bg-cyan-100 text-cyan-700'
                            : 'hover:bg-gray-100 text-gray-700 hover:text-gray-900'
                        }`}
                        title="Numbered List"
                        type="button"
                      >
                        <List className="w-4 h-4 text-current" />
                      </button>
                      <button
                        onClick={(e) => {
                          e.preventDefault();
                          e.stopPropagation();
                          formatText('formatBlock', '<blockquote>');
                          setShowToolbar(false);
                        }}
                        className={`p-2.5 rounded-lg transition-colors flex items-center justify-center ${
                          activeFormats.has('blockquote')
                            ? 'bg-cyan-100 text-cyan-700'
                            : 'hover:bg-gray-100 text-gray-700 hover:text-gray-900'
                        }`}
                        title="Quote"
                        type="button"
                      >
                        <Quote className="w-4 h-4 text-current" />
                      </button>
                    </div>
                  </div>
                )}
              </div>
            </div>

            {/* Editor Content */}
            <div className="flex-grow overflow-y-auto overflow-x-hidden p-3 sm:p-4 md:p-6 pr-12 sm:pr-14 md:pr-6 min-h-0 flex flex-col">
              {/* Story/Content Editor */}
              <div className="mb-3 sm:mb-4">
                <label className="block text-xs sm:text-sm font-semibold text-gray-700 mb-1.5 sm:mb-2">Story</label>
              </div>

              {/* Comprehensive Toolbar - All in One Line */}
              <div className="mb-3 sm:mb-4 p-2 sm:p-3 bg-gray-50 rounded-lg border border-gray-200">
                <div className="flex items-center gap-1 sm:gap-2 flex-wrap toolbar-responsive">
                  {/* Text Formatting */}
                  <button
                    onClick={(e) => {
                      e.preventDefault();
                      formatText('bold');
                    }}
                    className={`p-1.5 sm:p-2 rounded-lg transition-colors border ${
                      activeFormats.has('bold')
                        ? 'bg-cyan-100 border-cyan-300 text-cyan-700'
                        : 'hover:bg-white border-transparent hover:border-gray-300'
                    }`}
                    title="Bold (Ctrl+B)"
                  >
                    <Bold className="w-3.5 h-3.5 sm:w-4 sm:h-4" />
                  </button>
                  <button
                    onClick={(e) => {
                      e.preventDefault();
                      formatText('italic');
                    }}
                    className={`p-1.5 sm:p-2 rounded-lg transition-colors border ${
                      activeFormats.has('italic')
                        ? 'bg-cyan-100 border-cyan-300 text-cyan-700'
                        : 'hover:bg-white border-transparent hover:border-gray-300'
                    }`}
                    title="Italic (Ctrl+I)"
                  >
                    <Italic className="w-3.5 h-3.5 sm:w-4 sm:h-4" />
                  </button>
                  <button
                    onClick={(e) => {
                      e.preventDefault();
                      formatText('underline');
                    }}
                    className={`p-1.5 sm:p-2 rounded-lg transition-colors border ${
                      activeFormats.has('underline')
                        ? 'bg-cyan-100 border-cyan-300 text-cyan-700'
                        : 'hover:bg-white border-transparent hover:border-gray-300'
                    }`}
                    title="Underline (Ctrl+U)"
                    type="button"
                  >
                    <Underline className="w-3.5 h-3.5 sm:w-4 sm:h-4" />
                  </button>
                 
                <div className="w-px h-5 sm:h-6 bg-gray-300 mx-0.5 sm:mx-1" />
                 
                  {/* Headings */}
                  <button
                    onClick={(e) => {
                      e.preventDefault();
                      formatText('formatBlock', '<h1>');
                    }}
                    className={`p-1.5 sm:p-2 rounded-lg transition-colors border ${
                      activeFormats.has('h1')
                        ? 'bg-cyan-100 border-cyan-300 text-cyan-700'
                        : 'hover:bg-white border-transparent hover:border-gray-300'
                    }`}
                    title="Heading 1"
                  >
                    <Heading1 className="w-3.5 h-3.5 sm:w-4 sm:h-4" />
                  </button>
                  <button
                    onClick={(e) => {
                      e.preventDefault();
                      formatText('formatBlock', '<h2>');
                    }}
                    className={`p-1.5 sm:p-2 rounded-lg transition-colors border ${
                      activeFormats.has('h2')
                        ? 'bg-cyan-100 border-cyan-300 text-cyan-700'
                        : 'hover:bg-white border-transparent hover:border-gray-300'
                    }`}
                    title="Heading 2"
                  >
                    <Heading2 className="w-3.5 h-3.5 sm:w-4 sm:h-4" />
                  </button>
                  <button
                    onClick={(e) => {
                      e.preventDefault();
                      formatText('formatBlock', '<h3>');
                    }}
                    className={`p-1.5 sm:p-2 rounded-lg transition-colors border ${
                      activeFormats.has('h3')
                        ? 'bg-cyan-100 border-cyan-300 text-cyan-700'
                        : 'hover:bg-white border-transparent hover:border-gray-300'
                    }`}
                    title="Heading 3"
                  >
                    <Heading3 className="w-3.5 h-3.5 sm:w-4 sm:h-4" />
                  </button>
                 
                  <div className="w-px h-5 sm:h-6 bg-gray-300 mx-0.5 sm:mx-1" />
                 
                  {/* Alignment */}
                <button
                  onClick={(e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    formatText('justifyLeft');
                  }}
                    className={`p-1.5 sm:p-2 rounded-lg transition-colors border ${
                      activeFormats.has('justifyLeft')
                        ? 'bg-cyan-100 border-cyan-300 text-cyan-700'
                        : 'hover:bg-white border-transparent hover:border-gray-300'
                    }`}
                  title="Align Left"
                  type="button"
                >
                  <AlignLeft className="w-3.5 h-3.5 sm:w-4 sm:h-4" />
                </button>
                <button
                  onClick={(e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    formatText('justifyCenter');
                  }}
                    className={`p-1.5 sm:p-2 rounded-lg transition-colors border ${
                      activeFormats.has('justifyCenter')
                        ? 'bg-cyan-100 border-cyan-300 text-cyan-700'
                        : 'hover:bg-white border-transparent hover:border-gray-300'
                    }`}
                  title="Align Center"
                  type="button"
                >
                  <AlignCenter className="w-3.5 h-3.5 sm:w-4 sm:h-4" />
                </button>
                <button
                  onClick={(e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    formatText('justifyRight');
                  }}
                    className={`p-1.5 sm:p-2 rounded-lg transition-colors border ${
                      activeFormats.has('justifyRight')
                        ? 'bg-cyan-100 border-cyan-300 text-cyan-700'
                        : 'hover:bg-white border-transparent hover:border-gray-300'
                    }`}
                  title="Align Right"
                  type="button"
                >
                  <AlignRight className="w-3.5 h-3.5 sm:w-4 sm:h-4" />
                </button>
                 
                <div className="w-px h-5 sm:h-6 bg-gray-300 mx-0.5 sm:mx-1" />
                 
                  {/* Lists & Quote */}
                <button
                  onClick={(e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    formatText('insertUnorderedList');
                  }}
                    className={`p-1.5 sm:p-2 rounded-lg transition-colors border ${
                      activeFormats.has('insertUnorderedList')
                        ? 'bg-cyan-100 border-cyan-300 text-cyan-700'
                        : 'hover:bg-white border-transparent hover:border-gray-300'
                    }`}
                  title="Bullet List"
                  type="button"
                >
                  <List className="w-3.5 h-3.5 sm:w-4 sm:h-4" />
                </button>
                <button
                  onClick={(e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    formatText('insertOrderedList');
                  }}
                    className={`p-1.5 sm:p-2 rounded-lg transition-colors border ${
                      activeFormats.has('insertOrderedList')
                        ? 'bg-cyan-100 border-cyan-300 text-cyan-700'
                        : 'hover:bg-white border-transparent hover:border-gray-300'
                    }`}
                  title="Numbered List"
                  type="button"
                >
                  <List className="w-3.5 h-3.5 sm:w-4 sm:h-4" />
                </button>
                <button
                  onClick={(e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    formatText('formatBlock', '<blockquote>');
                  }}
                    className={`p-1.5 sm:p-2 rounded-lg transition-colors border ${
                      activeFormats.has('blockquote')
                        ? 'bg-cyan-100 border-cyan-300 text-cyan-700'
                        : 'hover:bg-white border-transparent hover:border-gray-300'
                    }`}
                  title="Quote"
                  type="button"
                >
                  <Quote className="w-3.5 h-3.5 sm:w-4 sm:h-4" />
                </button>
                 
                <div className="w-px h-5 sm:h-6 bg-gray-300 mx-0.5 sm:mx-1" />
                                
                {/* Advanced Formatting */}
                <button
                  onClick={(e) => {
                    e.preventDefault();
                    formatText('strikeThrough');
                  }}
                  className={`p-1.5 sm:p-2 rounded-lg transition-colors border toolbar-button ${
                    activeFormats.has('strikeThrough')
                      ? 'bg-cyan-100 border-cyan-300 text-cyan-700'
                      : 'hover:bg-white border-transparent hover:border-gray-300'
                  }`}
                  title="Strikethrough"
                  type="button"
                >
                  <Strikethrough className="w-3.5 h-3.5 sm:w-4 sm:h-4" />
                </button>
                <button
                  onClick={(e) => {
                    e.preventDefault();
                    formatText('formatBlock', '<pre>');
                  }}
                  className={`p-1.5 sm:p-2 rounded-lg transition-colors border toolbar-button ${
                    activeFormats.has('pre')
                      ? 'bg-cyan-100 border-cyan-300 text-cyan-700'
                      : 'hover:bg-white border-transparent hover:border-gray-300'
                  }`}
                  title="Code Block"
                  type="button"
                >
                  <Code className="w-3.5 h-3.5 sm:w-4 sm:h-4" />
                </button>
                <button
                  onClick={(e) => {
                    e.preventDefault();
                    formatText('insertHorizontalRule');
                  }}
                  className="p-1.5 sm:p-2 hover:bg-white rounded-lg transition-colors border border-transparent hover:border-gray-300 toolbar-button"
                  title="Horizontal Rule"
                  type="button"
                >
                  <Minus className="w-3.5 h-3.5 sm:w-4 sm:h-4" />
                </button>
                                
                <div className="w-px h-5 sm:h-6 bg-gray-300 mx-0.5 sm:mx-1 toolbar-divider" />
                                
                {/* Indentation */}
                <button
                  onClick={(e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    formatText('indent');
                  }}
                  className="p-1.5 sm:p-2 hover:bg-white rounded-lg transition-colors border border-transparent hover:border-gray-300 toolbar-button"
                  title="Indent"
                  type="button"
                >
                  <IndentIncrease className="w-3.5 h-3.5 sm:w-4 sm:h-4" />
                </button>
                <button
                  onClick={(e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    formatText('outdent');
                  }}
                  className="p-1.5 sm:p-2 hover:bg-white rounded-lg transition-colors border border-transparent hover:border-gray-300 toolbar-button"
                  title="Outdent"
                  type="button"
                >
                  <IndentDecrease className="w-3.5 h-3.5 sm:w-4 sm:h-4" />
                </button>
                                
                <div className="w-px h-5 sm:h-6 bg-gray-300 mx-0.5 sm:mx-1 toolbar-divider" />
                                
                {/* Media */}
                <button
                  onClick={() => fileInputRef.current?.click()}
                    className="p-1.5 sm:p-2 hover:bg-white rounded-lg transition-colors border border-transparent hover:border-gray-300"
                  title="Insert Image"
                >
                  <ImageIcon className="w-3.5 h-3.5 sm:w-4 sm:h-4" />
                </button>
                <input
                  ref={fileInputRef}
                  type="file"
                  accept="image/*"
                  onChange={handleImageUpload}
                  className="hidden"
                />
                <button
                    onClick={() => setShowVideoOptions(true)}
                    className="p-1.5 sm:p-2 hover:bg-white rounded-lg transition-colors border border-transparent hover:border-gray-300"
                  title="Insert Video"
                >
                  <Video className="w-3.5 h-3.5 sm:w-4 sm:h-4" />
                </button>
                  <input
                    ref={videoInputRef}
                    type="file"
                    accept="video/*"
                    onChange={handleVideoUpload}
                    className="hidden"
                  />
                <button
                  onClick={() => {
                    const selection = window.getSelection();
                    if (!selection || selection.rangeCount === 0 || selection.toString().trim() === '') {
                      alert('Please select text to create a link');
                      return;
                    }
                   
                    const url = prompt('Enter link URL:', 'https://');
                    if (url && url.trim()) {
                      if (!url.startsWith('http://') && !url.startsWith('https://')) {
                        formatText('createLink', `https://${url}`);
                      } else {
                        formatText('createLink', url);
                      }
                    }
                  }}
                    className="p-1.5 sm:p-2 hover:bg-white rounded-lg transition-colors border border-transparent hover:border-gray-300"
                  title="Insert Link"
                >
                  <LinkIcon className="w-3.5 h-3.5 sm:w-4 sm:h-4" />
                </button>
              </div>
              </div>

              {/* Featured Image */}
              {featuredImage && (
                <div className="mb-4 sm:mb-6 relative group">
                  <img
                    src={featuredImage}
                    alt="Featured"
                    className="w-full h-32 sm:h-40 md:h-44 object-cover rounded-xl sm:rounded-2xl"
                  />
                  <button
                    onClick={() => setFeaturedImage('')}
                    className="absolute top-2 right-2 p-1.5 sm:p-2 bg-black/50 hover:bg-black/70 rounded-lg opacity-0 group-hover:opacity-100 transition-opacity"
                  >
                    <X className="w-3.5 h-3.5 sm:w-4 sm:h-4 text-white" />
                  </button>
                </div>
              )}

              {/* Content Editor */}
              <div
                ref={editorRef}
                contentEditable
                onInput={updateContent}
                onPaste={handlePaste}
                onBlur={updateContent}
                onKeyUp={() => {
                  // Update active formats after typing to ensure toolbar reflects current state
                  setTimeout(updateActiveFormats, 0);
                }}
                onKeyDown={() => {
                  // Ensure cursor is visible after key presses
                  if (editorRef.current) {
                    setTimeout(() => {
                      const selection = window.getSelection();
                      if (selection && selection.rangeCount > 0) {
                        const range = selection.getRangeAt(0);
                        // Ensure cursor is visible
                        try {
                          range.collapse(true);
                          selection.removeAllRanges();
                          selection.addRange(range);
                        } catch (err) {
                          // Ignore errors
                        }
                      }
                    }, 0);
                  }
                }}
                onClick={() => {
                  // Ensure cursor is visible on click
                  if (editorRef.current) {
                    setTimeout(() => {
                      editorRef.current?.focus();
                    }, 0);
                  }
                }}
                className="min-h-[300px] sm:min-h-[350px] md:min-h-[400px] text-base sm:text-lg leading-relaxed text-gray-700 focus:outline-none prose prose-sm sm:prose-base md:prose-lg max-w-none"
                style={{
                  wordBreak: 'break-word',
                  caretColor: '#06b6d4', // Cyan cursor color for visibility
                  outline: 'none',
                  overflow: 'visible', // Ensure buttons are not clipped
                  position: 'relative', // Create stacking context
                }}
                suppressContentEditableWarning={true}
              />


            </div>

            {/* Topics */}
            <div className="px-3 sm:px-4 pt-2 border-t border-gray-200 pb-1 sm:pb-2 hashtags-section">
              <label className="block text-xs sm:text-sm font-semibold text-gray-700 mb-1 hashtags-label">
                #Hashtags
              </label>
              <div className="flex flex-wrap gap-0.5 sm:gap-2 mb-1 sm:mb-2 hashtags-container">
                {topics.map((topic) => (
                  <span
                    key={topic}
                    className="inline-flex items-center gap-0.5 sm:gap-2 px-1 sm:px-3 py-0.25 sm:py-1 bg-gradient-to-r from-cyan-100 to-teal-100 text-cyan-700 rounded-full text-xs font-medium hashtag-tag"
                  >
                    #{topic}
                    <button
                      onClick={() => removeTopic(topic)}
                      className="hover:text-cyan-900"
                    >
                      <X className="w-2 h-2 sm:w-3 sm:h-3" />
                    </button>
                  </span>
                ))}
              </div>
              <div className="flex gap-0.5 sm:gap-2 hashtag-input-section">
                <input
                  type="text"
                  placeholder="Add a topic..."
                  value={newTopic}
                  onChange={(e) => setNewTopic(e.target.value)}
                  onKeyPress={(e) => {
                    if (e.key === 'Enter') {
                      e.preventDefault();
                      addTopic();
                    }
                  }}
                  className="flex-1 px-1.5 sm:px-4 py-0.5 sm:py-2 text-xs sm:text-sm border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-cyan-500 hashtag-input"
                />
                <button
                  onClick={addTopic}
                  className="px-1.5 sm:px-4 py-0.5 sm:py-2 bg-gradient-to-r from-cyan-500 to-teal-500 text-white rounded-lg hover:from-cyan-600 hover:to-teal-600 transition-all flex-shrink-0 hashtag-add-btn"
                >
                  <Plus className="w-2.5 h-2.5 sm:w-3 sm:h-3" />
                </button>
              </div>
            </div>

            {/* Footer Stats */}
            <div className="p-2 sm:p-3 border-t border-gray-200 bg-gray-50 flex flex-col sm:flex-row sm:items-center sm:justify-between gap-2 sm:gap-0 flex-shrink-0">
              <div className="flex items-center gap-3 sm:gap-4 text-xs sm:text-sm text-gray-600 flex-wrap">
                <span>{wordCount} words</span>
                <span>{readTime} min read</span>
                {lastSaved && (
                  <span className="text-xs text-gray-500 hidden sm:inline">
                    Last saved: {lastSaved.toLocaleTimeString()}
                  </span>
                )}
              </div>
              <div className="flex items-center gap-1.5 sm:gap-2">
                <button
                  onClick={() => saveDraft(false)}
                  disabled={isLoading}
                  className="px-3 sm:px-4 py-1.5 sm:py-2 bg-gray-200 hover:bg-gray-300 rounded-lg text-xs sm:text-sm font-medium transition-colors disabled:opacity-50"
                >
                  {isLoading ? 'Saving...' : 'Save Draft'}
                </button>
                <button
                  onClick={publishBlog}
                  disabled={isPublishing}
                  className="px-4 sm:px-6 py-1.5 sm:py-2 bg-gradient-to-r from-cyan-500 to-teal-500 hover:from-cyan-600 hover:to-teal-600 text-white rounded-lg text-xs sm:text-sm font-medium transition-all disabled:opacity-50 flex items-center gap-1.5 sm:gap-2"
                >
                  <Send className="w-3.5 h-3.5 sm:w-4 sm:h-4" />
                  <span className="hidden sm:inline">{isPublishing ? 'Publishing...' : 'Publish'}</span>
                  <span className="sm:hidden">{isPublishing ? '...' : 'Publish'}</span>
                </button>
              </div>
            </div>
          </div>

          {/* Preview Panel */}
          {showPreview && (
            <div className="w-full md:w-1/2 border-t md:border-t-0 md:border-l border-gray-200 overflow-y-auto bg-gray-50 p-3 sm:p-4 md:p-6">
              <h3 className="text-xl sm:text-2xl font-bold mb-3 sm:mb-4">Preview</h3>
              <article className="bg-white rounded-xl sm:rounded-2xl p-4 sm:p-6 md:p-8 shadow-lg">
                {featuredImage && (
                  <img
                    src={featuredImage}
                    alt="Featured"
                    className="w-full h-32 sm:h-40 md:h-44 object-cover rounded-lg sm:rounded-xl mb-4 sm:mb-6"
                  />
                )}
                <h1 className="text-2xl sm:text-3xl md:text-4xl font-bold mb-3 sm:mb-4 break-words">{title || 'Untitled'}</h1>
                {authorName && (
                  <p className="text-base sm:text-lg text-gray-600 mb-4 sm:mb-6">By {authorName}</p>
                )}
                <div
                  className="prose prose-sm sm:prose-base md:prose-lg max-w-none preview-content"
                  dangerouslySetInnerHTML={{ __html: cleanContentForPreview(content) }}
                  style={{
                    wordBreak: 'break-word',
                  }}
                />
              </article>
            </div>
          )}
        </div>
      </div>
    </div>
  );
};
export default ModernBlogEditorV1;
